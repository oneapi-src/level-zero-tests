#!/usr/bin/env python3
# Copyright (C) 2020 Intel Corporation
# SPDX-License-Identifier: MIT

import os
import signal
import sys
import time

from zesys import *
from zesys.zes_wrap import *
from zesys.output import *

pr = logger.pr

#
# ZE common support
#

def default_structure_init(stype, obj):
    obj.stype = stype
    return obj

def ze_typed_structure(stype):
    ctor_map = { ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES : ze_driver_properties_t,
                 ZE_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES : ze_driver_ipc_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES : ze_device_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_COMPUTE_PROPERTIES : ze_device_compute_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_MODULE_PROPERTIES : ze_device_module_properties_t,
                 ZE_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES : ze_command_queue_group_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_MEMORY_PROPERTIES : ze_device_memory_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_MEMORY_ACCESS_PROPERTIES : ze_device_memory_access_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_CACHE_PROPERTIES : ze_device_cache_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_IMAGE_PROPERTIES : ze_device_image_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_P2P_PROPERTIES : ze_device_p2p_properties_t,
                 ZE_STRUCTURE_TYPE_CONTEXT_DESC : ze_context_desc_t,
                 ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC : ze_command_queue_desc_t,
                 ZE_STRUCTURE_TYPE_COMMAND_LIST_DESC : ze_command_list_desc_t,
                 ZE_STRUCTURE_TYPE_EVENT_POOL_DESC : ze_event_pool_desc_t,
                 ZE_STRUCTURE_TYPE_EVENT_DESC : ze_event_desc_t,
                 ZE_STRUCTURE_TYPE_FENCE_DESC : ze_fence_desc_t,
                 ZE_STRUCTURE_TYPE_IMAGE_DESC : ze_image_desc_t,
                 ZE_STRUCTURE_TYPE_IMAGE_PROPERTIES : ze_image_properties_t,
                 ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC : ze_device_mem_alloc_desc_t,
                 ZE_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC : ze_host_mem_alloc_desc_t,
                 ZE_STRUCTURE_TYPE_MEMORY_ALLOCATION_PROPERTIES : ze_memory_allocation_properties_t,
                 ZE_STRUCTURE_TYPE_MODULE_DESC : ze_module_desc_t,
                 ZE_STRUCTURE_TYPE_MODULE_PROPERTIES : ze_module_properties_t,
                 ZE_STRUCTURE_TYPE_KERNEL_DESC : ze_kernel_desc_t,
                 ZE_STRUCTURE_TYPE_KERNEL_PROPERTIES : ze_kernel_properties_t,
                 ZE_STRUCTURE_TYPE_SAMPLER_DESC : ze_sampler_desc_t,
                 ZE_STRUCTURE_TYPE_PHYSICAL_MEM_DESC : ze_physical_mem_desc_t }
    init_map = { }

    ctor = ctor_map.get(stype, ze_base_properties_t)
    init = init_map.get(stype, default_structure_init)
    return init(stype, ctor())

def zes_device_properties_init(stype, obj):
    obj = default_structure_init(stype, obj)
    obj.core.stype = ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES
    return obj

def zes_typed_structure(stype):
    ctor_map = { ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES : zes_device_properties_t,
                 ZES_STRUCTURE_TYPE_PCI_PROPERTIES : zes_pci_properties_t,
                 ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES : zes_pci_bar_properties_t,
                 ZES_STRUCTURE_TYPE_DIAG_PROPERTIES : zes_diag_properties_t,
                 ZES_STRUCTURE_TYPE_ENGINE_PROPERTIES : zes_engine_properties_t,
                 ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES : zes_fabric_port_properties_t,
                 ZES_STRUCTURE_TYPE_FAN_PROPERTIES : zes_fan_properties_t,
                 ZES_STRUCTURE_TYPE_FIRMWARE_PROPERTIES : zes_firmware_properties_t,
                 ZES_STRUCTURE_TYPE_FREQ_PROPERTIES : zes_freq_properties_t,
                 ZES_STRUCTURE_TYPE_LED_PROPERTIES : zes_led_properties_t,
                 ZES_STRUCTURE_TYPE_MEM_PROPERTIES : zes_mem_properties_t,
                 ZES_STRUCTURE_TYPE_PERF_PROPERTIES : zes_perf_properties_t,
                 ZES_STRUCTURE_TYPE_POWER_PROPERTIES : zes_power_properties_t,
                 ZES_STRUCTURE_TYPE_PSU_PROPERTIES : zes_psu_properties_t,
                 ZES_STRUCTURE_TYPE_RAS_PROPERTIES : zes_ras_properties_t,
                 ZES_STRUCTURE_TYPE_SCHED_PROPERTIES : zes_sched_properties_t,
                 ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES : zes_sched_timeout_properties_t,
                 ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES : zes_sched_timeslice_properties_t,
                 ZES_STRUCTURE_TYPE_STANDBY_PROPERTIES : zes_standby_properties_t,
                 ZES_STRUCTURE_TYPE_TEMP_PROPERTIES : zes_temp_properties_t,
                 ZES_STRUCTURE_TYPE_DEVICE_STATE : zes_device_state_t,
                 ZES_STRUCTURE_TYPE_PROCESS_STATE : zes_process_state_t,
                 ZES_STRUCTURE_TYPE_PCI_STATE : zes_pci_state_t,
                 ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG : zes_fabric_port_config_t,
                 ZES_STRUCTURE_TYPE_FABRIC_PORT_STATE : zes_fabric_port_state_t,
                 ZES_STRUCTURE_TYPE_FAN_CONFIG : zes_fan_config_t,
                 ZES_STRUCTURE_TYPE_FREQ_STATE : zes_freq_state_t,
                 ZES_STRUCTURE_TYPE_OC_CAPABILITIES : zes_oc_capabilities_t,
                 ZES_STRUCTURE_TYPE_LED_STATE : zes_led_state_t,
                 ZES_STRUCTURE_TYPE_MEM_STATE : zes_mem_state_t,
                 ZES_STRUCTURE_TYPE_PSU_STATE : zes_psu_state_t,
                 ZES_STRUCTURE_TYPE_BASE_STATE : zes_base_state_t,
                 ZES_STRUCTURE_TYPE_RAS_CONFIG : zes_ras_config_t,
                 ZES_STRUCTURE_TYPE_RAS_STATE : zes_ras_state_t,
                 ZES_STRUCTURE_TYPE_TEMP_CONFIG : zes_temp_config_t }
    init_map = { ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES : zes_device_properties_init }

    ctor = ctor_map.get(stype, zes_base_properties_t)
    init = init_map.get(stype, default_structure_init)
    return init(stype, ctor())

def zes_typed_array(stype, count):
    ctor_map = { ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES : zes_pci_bar_properties_array,
                 ZES_STRUCTURE_TYPE_PROCESS_STATE : zes_process_state_array }
    init_map = { }

    # no default array constructor, size must be known:
    array_ctor = ctor_map[stype]
    init = init_map.get(stype, default_structure_init)

    array = array_ctor(count)
    for i in range(count):
        init(stype, array[i])

    return array

#
# API STUBS for testing
#

if util.developer_mode() == "STUB_API":
    stubs = stub.api()
elif util.developer_mode() == "STUB_TOPO":
    stubs = stub.topo()
else:
    stubs = {}

for f in stubs:
    exec(stub.replacement(f, "stubs"))

#
# Parse ZE function result, stripping (first) return code and converting non-success to exception,
# forwarding to stub handler if function has been replaced
#
def zeCall(rc):
    if type(rc) == type({}):
        return rc['fn'](*rc['args'], **rc['kwargs'])
    elif type(rc) in (type(()),type([])):
        val = rc[1:]
        rc = rc[0]
        if len(val) == 1:
            val = val[0]
    else:
        val = None
    if rc == ZE_RESULT_ERROR_UNSUPPORTED_FEATURE:
        raise NotImplementedError
    elif rc != ZE_RESULT_SUCCESS:
        raise ValueError(resultString(rc))
    return val

# Helper for indexing lists
# To allow *args to be empty, change to: return args and zip(range(len(args[0])), *args)
def indexed(*args):
    return zip(range(len(args[0])), *args)

def driverUUIDs(count, drivers):
    uuids = []
    for i in range(count):
        driver = drivers[i]
        driver_props = ze_typed_structure(ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES)
        zeCall(zeDriverGetProperties(driver, driver_props))
        uuid_string = uuid_string_t()
        driver_uuid_to_string(driver_props.uuid, uuid_string)
        uuids.append(str(uuid_string.id))
    return uuids

def listDrivers(count, drivers):
    pr.err("Available drivers:")
    for i in range(count):
        pr.err("Driver", i, ":")
        driver = drivers[i]
        api_version = zeCall(zeDriverGetApiVersion(driver))
        pr.err("  API version:", versionString(api_version))
        driver_props = ze_typed_structure(ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES)
        zeCall(zeDriverGetProperties(driver, driver_props))
        uuid_string = uuid_string_t()
        driver_uuid_to_string(driver_props.uuid, uuid_string)
        pr.err("  uuid:", uuid_string.id)
        pr.err("  driver version:", driver_props.driverVersion)
        ipcProps = ze_typed_structure(ZE_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES)
        zeCall(zeDriverGetIpcProperties(driver, ipcProps))
        pr.err("  IPC passing:", ipcPropertiesString(ipcProps.flags))

def listDriversAndFail(count, drivers):
    listDrivers(count, drivers)
    pr.fail("Use --driver to specify a valid driver")

def listDevices(driverIndices, deviceCounts, deviceLists):
    pr.err("Available devices:")
    for driver, count, devices in zip(driverIndices, deviceCounts, deviceLists):
        for i in range(count):
            if len(driverIndices) > 1:
                pr.err("Device", str(driver) + "." + str(i), ":")
            else:
                pr.err("Device", i, ":")
            device = devices[i]
            device_properties = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, device_properties))
            devType = deviceTypeString(device_properties.type)
            pr.err("  type:", devType)
            pr.err("  name:", device_properties.name)
            pr.err("  vendorId:", hex(device_properties.vendorId))
            pr.err("  deviceId:", hex(device_properties.deviceId))
            uuid_string = uuid_string_t()
            device_uuid_to_string(device_properties.uuid, uuid_string)
            pr.err("  uuid:", uuid_string.id)

def listDevicesAndFail(driverIndices, deviceCounts, deviceLists):
    listDevices(driverIndices, deviceCounts, deviceLists)
    pr.fail("Use --device to specify a set of valid devices")

def getDrivers(driverSelection):
    driverCount = uint32_ptr()
    zeCall(zeDriverGet(driverCount.cast(), None))
    numDrivers = driverCount.value()
    if numDrivers < 1:
        pr.fail("No compatible drivers found")

    drivers = ze_driver_handle_array(numDrivers)
    zeCall(zeDriverGet(driverCount.cast(), drivers.cast()))

    if driverSelection:
        indices = []
        uuids = driverUUIDs(numDrivers, drivers)
        for sel in driverSelection:
            sel = sel.lower()

            if sel == "list":
                listDrivers(numDrivers, drivers)
                exit(0)

            if sel in uuids:
                i = uuids.index(sel)
            else:
                try:
                    i = int(sel, 0)
                    if i < 0 or i >= numDrivers:
                        raise
                except:
                    pr.err("Error: Illegal driver index/UUID", sel, "specified")
                    listDriversAndFail(numDrivers, drivers)
            indices.append(i)

        # uniquify:
        indices = list(set(indices))
        indices.sort()
    else:
        indices = range(numDrivers)

    return indices, drivers

def getDeviceUUIDs(deviceCounts, deviceLists):
    uuids = []
    for count, devices in zip(deviceCounts, deviceLists):
        for i in range(count):
            device = devices[i]
            device_properties = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, device_properties))
            uuid_string = uuid_string_t()
            device_uuid_to_string(device_properties.uuid, uuid_string)
            uuids.append(str(uuid_string.id))
    return uuids

def listDevices(driverIndices, deviceCounts, deviceLists):
    pr.err("Available devices:")
    for driver, count, devices in zip(driverIndices, deviceCounts, deviceLists):
        for i in range(count):
            if len(driverIndices) > 1:
                pr.err("Device", str(driver) + "." + str(i), ":")
            else:
                pr.err("Device", i, ":")
            device = devices[i]
            device_properties = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, device_properties))
            devType = deviceTypeString(device_properties.type)
            pr.err("  type:", devType)
            pr.err("  name:", device_properties.name)
            pr.err("  vendorId:", hex(device_properties.vendorId))
            pr.err("  deviceId:", hex(device_properties.deviceId))
            uuid_string = uuid_string_t()
            device_uuid_to_string(device_properties.uuid, uuid_string)
            pr.err("  uuid:", uuid_string.id)

def firstMatch(sel, *places):
    for place in places:
        if sel in place:
            return place.index(sel)
    return None

def getDevices(driverIndices, drivers, deviceSelection):
    deviceFound = False
    deviceCounts = []
    deviceLists = []

    for _,driver in zip(driverIndices, drivers):
        deviceCount = uint32_ptr()
        zeCall(zeDeviceGet(driver, deviceCount.cast(), None))

        if deviceCount.value() > 0:
            deviceFound = True
            driverDevices = ze_device_handle_array(deviceCount.value())
            zeCall(zeDeviceGet(driver, deviceCount.cast(), driverDevices.cast()))
        else:
            driverDevices = None

        deviceCounts.append(deviceCount.value())
        deviceLists.append(driverDevices)

    if not deviceFound:
        pr.fail("No devices found")

    allUUIDs = getDeviceUUIDs(deviceCounts, deviceLists)
    allIndices = [ (r,d) for r,c in indexed(deviceCounts) for d in range(c) ]

    expandedIDs = [ str(driverIndices[r]) + "." + str(d) for r,d in allIndices ]

    if len(driverIndices) > 1:
        deviceIDs = expandedIDs
    else:
        deviceIDs = [ str(d) for r, d in allIndices ]

    if deviceSelection:
        indices = []
        deviceUUIDs = []
        for sel in deviceSelection:
            sel = sel.lower()

            if sel == "list":
                listDevices(driverIndices, deviceCounts, deviceLists)
                exit(0)

            i = firstMatch(sel, allUUIDs, deviceIDs, expandedIDs)

            if i is None:
                pr.err("Error: Illegal device index/UUID", sel, "specified")
                listDevicesAndFail(driverIndices, deviceCounts, deviceLists)
            else:
                indices.append(allIndices[i])
                deviceUUIDs.append(allUUIDs[i])

        if len(driverIndices) > 1:
            deviceIDs = [ str(driverIndices[r]) + "." + str(d) for r, d in indices ]
        else:
            deviceIDs = [ str(d) for r, d in indices ]
    else:
        indices = allIndices
        deviceUUIDs = allUUIDs

    sysmanDevices = [deviceLists[r][d] for r,d in indices]

    return deviceIDs, deviceUUIDs, sysmanDevices

def findTestSuite(diagCount, diags, name):
    diagProps = zes_typed_structure(ZES_STRUCTURE_TYPE_DIAG_PROPERTIES)
    match = None
    for i in range(diagCount):
        diag = diags[i]
        zeCall(zesDiagnosticsGetProperties(diag, diagProps))
        # TODO: should we allow regexp matching?
        if name == diagProps.name:
            if match is None:
                match = i
            else:
                logger.pr.err("ERROR:", name, "does not specify one test suite exactly, use index form")
                raise ValueError(name)

    if match is None:
        logger.pr.err("ERROR:", name, "does not match any test suite name")
        raise ValueError(name)

    return match

def parseTestSuite(diagCount, diags, opts):
    opt_string = " ".join(opts)
    suite = opts.pop(0)
    try:
        i = int(suite, 0)
        assert(i < diagCount)
    except:
        i = findTestSuite(diagCount, diags, suite)

    diag = diags[i]

    if opts:
        try:
            first = int(opts.pop(0), 0)
            if opts:
                last = int(opts.pop(0), 0)
            else:
                last = first
            assert(not opts)
        except:
            logger.pr.err("ERROR:", opt_string, "should be of form SUITE [N [N]]")
            raise ValueError(opts)
        else:
            diagProps = zes_typed_structure(ZES_STRUCTURE_TYPE_DIAG_PROPERTIES)
            zeCall(zesDiagnosticsGetProperties(diag, diagProps))
            if diagProps.haveTests:
                firstFound, lastFound = False, False
                testCount = uint32_ptr()
                try:
                    zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), None))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
                else:
                    tests = zes_diag_test_array(testCount.value())
                    zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), tests.cast()))
                    for t in range(testCount.value()):
                        test = tests[t]
                        if test.index == first:
                            firstFound = True
                        if test.index == last:
                            lastFound = True
                if not firstFound and first != ZES_DIAG_FIRST_TEST_INDEX:
                    logger.pr.err("WARNING:", first, "not found in test suite")
                if not lastFound and last != first and ((last & 0xffffffff) !=
                                                        (ZES_DIAG_LAST_TEST_INDEX & 0xffffffff)):
                    logger.pr.err("WARNING:", last, "not found in test suite")
            else:
                logger.pr.err("WARNING: Test suite has no individual subtests")
    else:
        first, last = ZES_DIAG_FIRST_TEST_INDEX, ZES_DIAG_LAST_TEST_INDEX

    return diag, first, last

def sigintHandler(sigNum, frame):
    state.maxIterations = 0

#
# Main program
#
def main():
    global deviceUUID

    args = arg.parse()

    if state.maxIterations > 1:
        signal.signal(signal.SIGINT, sigintHandler)

    driverIndices, drivers = getDrivers(args.driver)

    deviceIDs, deviceUUIDs, devices = getDevices(driverIndices, drivers, args.device)

    generatingDeviceReport = False

    if args.show_all:
        args.show_temp, args.show_power, args.show_freq, args.show_util = True, True, True, True
        args.show_mem, args.show_pci, args.show_fabric_ports = True, True, True
        args.show_standby, args.show_errors = True, True

    if (args.show_device or args.show_processes or args.show_scheduler or args.show_temp or
        args.show_power or args.show_freq or args.show_util or args.show_mem or args.show_pci or
        args.show_fabric_ports or args.show_standby or args.show_errors or args.show_diag or
        args.show_fans or args.show_firmware or args.show_oc or args.show_leds or args.show_perf or
        args.show_psu):

        generatingDeviceReport = True

        if not args.show_inventory:
            args.show_telemetry = True

    elif args.show_inventory or args.show_telemetry:

        args.show_temp, args.show_power, args.show_freq, args.show_util = True, True, True, True
        args.show_mem, args.show_pci, args.show_fabric_ports = True, True, True
        args.show_standby, args.show_errors = True, True

        generatingDeviceReport = True

    if args.show_topo:
        generatingDeviceReport = True

    if not generatingDeviceReport:
        otree.setNullNodeClass()

    Node = otree.NodeClass

    if args.poll and args.poll > 0 and args.poll <= 60:
        pollInterval = args.poll
    else:
        pollInterval = 1

    pollDelayRequired = False
    telemetryClosures = []

    if args.reset:
        if len(devices) != 1:
            pr.fail("Cannot reset more than one GPU at a time")

        deviceName = "%s [%s]" % (deviceIDs[0], deviceUUID(deviceUUIDs[0]))

        if not args.yes:
            answer = input("Do you really want to reset device " + deviceName + "? ")
            args.yes = answer.lower() in ("y", "yes")

        if args.yes:
            if args.dry_run:
                pr("Would RESET device", deviceName)
            else:
                pr("RESETTING device", deviceName)
                zeCall(zesDeviceReset(devices[0], args.force))
        else:
            pr("NOT resetting device")

        sys.exit(0)

    if args.run_diag:
        if len(devices) != 1:
            pr.fail("Cannot test more than one GPU at a time")

        diagCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumDiagnosticTestSuites(devices[0], diagCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            diags = zes_diag_handle_array(diagCount.value())
            zeCall(zesDeviceEnumDiagnosticTestSuites(devices[0], diagCount.cast(), diags.cast()))

        suite, first, last = parseTestSuite(diagCount.value(), diags, args.run_diag)

        if args.dry_run:
            deviceName = "%s [%s]" % (deviceIDs[0], deviceUUID(deviceUUIDs[0]))
            pr("Would run diagnostics on device", deviceName)
        else:
            result = zeCall(zesDiagnosticsRunTests(suite, first, last))
            pr("Diagnostic test result:", diagResultString(result))

        sys.exit(result)

    if args.wait_events is not None:
        if len(driverIndices) != 1:
            pr.err("ERROR: can only wait on events from one driver at a time")
            sys.exit(1)

        allEvents = (ZES_EVENT_TYPE_FLAG_DEVICE_DETACH | ZES_EVENT_TYPE_FLAG_DEVICE_ATTACH |
                     ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_ENTER |
                     ZES_EVENT_TYPE_FLAG_DEVICE_SLEEP_STATE_EXIT | ZES_EVENT_TYPE_FLAG_FREQ_THROTTLED |
                     ZES_EVENT_TYPE_FLAG_ENERGY_THRESHOLD_CROSSED | ZES_EVENT_TYPE_FLAG_TEMP_CRITICAL |
                     ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD1 | ZES_EVENT_TYPE_FLAG_TEMP_THRESHOLD2 |
                     ZES_EVENT_TYPE_FLAG_MEM_HEALTH | ZES_EVENT_TYPE_FLAG_FABRIC_PORT_HEALTH |
                     ZES_EVENT_TYPE_FLAG_PCI_LINK_HEALTH | ZES_EVENT_TYPE_FLAG_RAS_CORRECTABLE_ERRORS |
                     ZES_EVENT_TYPE_FLAG_RAS_UNCORRECTABLE_ERRORS |
                     ZES_EVENT_TYPE_FLAG_DEVICE_RESET_REQUIRED)

        if len(args.wait_events) > 1:
            selectedEvents = int(args.wait_events[1],0) & allEvents
        else:
            selectedEvents = allEvents

        for device in devices:
            try:
                zeCall(zesDeviceEventRegister(device, selectedEvents))
            except NotImplementedError:
                pass
            except ValueError:
                logger.reportZeException()

        driver = drivers[0]
        if len(args.wait_events) > 0:
            timeout = int(args.wait_events[0],0) & 0xffffffff
        else:
            timeout = 1000
        count = len(devices)
        phDevices = ze_device_handle_array(count)
        for i, device in indexed(devices):
            phDevices[i] = device
        pEvents = zes_event_type_flags_array(count)

        try:
            numEvents = zeCall(zesDriverEventListen(driver, timeout, count, phDevices.cast(), pEvents.cast()))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            if numEvents:
                pr(numEvents, "device(s) reported events:")
                for i in range(count):
                    events = eventsString(pEvents[i])
                    pr("   ", deviceIDs[i], ":", deviceUUIDs[i], events)
            else:
                pr("No events reported")

        for device in devices:
            try:
                zeCall(zesDeviceEventRegister(device, 0))
            except NotImplementedError:
                pass
            except ValueError:
                logger.reportZeException()

        sys.exit(0)

    if args.show_topo:
        fabric = []
        fabricMap = {}
        fabricAttach = {}
        fabricIds = []

        try:
            for devID, device in zip(deviceIDs, devices):
                portCount = uint32_ptr()
                zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), None))
                ports = zes_fabric_port_handle_array(portCount.value())
                zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), ports.cast()))

                for i in range(portCount.value()):
                    port = ports[i]
                    pp = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES)
                    zeCall(zesFabricPortGetProperties(port, pp))
                    src = (pp.portId.fabricId, pp.portId.attachId, pp.portId.portNumber)
                    ps = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_STATE)
                    zeCall(zesFabricPortGetState(port, ps))
                    if ps.status not in [ZES_FABRIC_PORT_STATUS_HEALTHY, ZES_FABRIC_PORT_STATUS_DEGRADED]:
                        continue
                    dst = (ps.remotePortId.fabricId, ps.remotePortId.attachId, ps.remotePortId.portNumber)
                    fabric.append((src,dst))
                    if src[0] not in fabricIds:
                        fabricIds.append(src[0])
                    sds = fabricAttach.setdefault(src[0], set())
                    sds.add(src[1])
                    sdd = fabricAttach.setdefault(dst[0], set())
                    sdd.add(dst[1])
                    if devID not in fabricMap.setdefault(src[0], [devID]):
                        fabricMap[src[0]].append(devID)
                        pr.err("Fabric ID", src[0], "maps to multiple devices:", ",".join(fabricMap[src[0]]))
        except NotImplementedError:
            pr("Not supported by current driver")
        except ValueError:
            logger.reportZeException()

        if args.show_topo == "matrix":
            matrix = [["-"] * len(deviceIDs) for _ in deviceIDs]
            for d in range(len(deviceIDs)):
                matrix[d][d] = "X"
            for connection in fabric:
                for src in fabricMap.get(connection[0][0],[]):
                    s = deviceIDs.index(src)
                    for dest in fabricMap.get(connection[1][0],[]):
                        d = deviceIDs.index(dest)
                        matrix[s][d] = "x"
            if args.uuid_index:
                header_column = ["", " "*36]
            else:
                header_column = [""]
            pr("\t".join(header_column + list(map(str, deviceIDs))))
            for src in (deviceIDs):
                s = deviceIDs.index(src)
                if args.uuid_index:
                    header_column = [src, deviceUUIDs[s]]
                else:
                    header_column = [src]
                pr("\t".join(header_column + matrix[s]))

        if args.show_topo == "graph":
            pr("graph fabric {")
            for f in fabricIds:
                m = fabricMap.get(f,[])
                if args.uuid_index:
                    m = [d + "\\n" + deviceUUIDs[deviceIDs.index(d)] for d in m]
                m = ["Device " + d for d in m]
                pr('    "d{}" [label="{}" shape=box style=filled fillcolor="#cccccc"]'.format(f,"\\n".join(m)))
            for f,m in fabricAttach.items():
                for sd in m:
                    pr('    "sd{},{}" [label="{}" style=filled fillcolor="#eeeeee"]'.format(f,sd,sd))
                    pr('    "d{}" -- "sd{},{}" [color="#888888"]'.format(f,f,sd))
            shown = set()
            for (f,s,p),(rf,rs,rp) in fabric:
                if (f,s,p) not in shown:
                    shown.add((f,s,p))
                    shown.add((rf,rs,rp))
                    pr('    "sd{},{}" -- "sd{},{}"'.format(f,s,rf,rs))
            pr("}")

        if args.show_topo == "info":
            topNode = Node(None, "Devices", None)
            for devID, devUUID in zip(deviceIDs, deviceUUIDs):
                for fabricId in fabricIds:
                    if devID in fabricMap[fabricId]:
                        devNode = Node(topNode, "Device", None, ("Index", devID), ("UUID", deviceUUID(devUUID)))
                        Node(devNode, "FabricID", fabricId)
                        sdsNode = Node(devNode, "AttachPoints", None)
                        sds = list(fabricAttach[fabricId])
                        sds.sort()
                        for sd in sds:
                            sdNode = Node(sdsNode, "AttachPoint", None, ("Index", sd))
                            for (f,s,p),(rf,rs,rp) in fabric:
                                if (f,s) == (fabricId,sd):
                                    portNode = Node(sdNode, "Port", None, ("Index", p))
                                    Node(portNode, "RemoteFabricId", rf)
                                    Node(portNode, "RemoteAttachId", rs)
                                    Node(portNode, "RemotePortNumber", rp)
            topNode.output(1)
            topNode.outputComplete()

        sys.exit(0)

    if args.ascii:
        degC = "degC"
    else:
        degC = "Â°C"

    topNode = Node(None, "Devices", None)

    for devID, devUUID, device in zip(deviceIDs, deviceUUIDs, devices):
        devNode = Node(topNode, "Device", None, ("Index", devID), ("UUID", deviceUUID(devUUID)))
        if args.show_device:
            coreProps = ze_typed_structure(ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES)
            zeCall(zeDeviceGetProperties(device, coreProps))
            Node(devNode, "Name", coreProps.name)
            Node(devNode, "Type", deviceTypeString(coreProps.type))
            Node(devNode, "VendorId", hex(coreProps.vendorId))
            Node(devNode, "DeviceId", hex(coreProps.deviceId))
            if args.show_inventory:
                try:
                    props = zes_typed_structure(ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES)
                    zeCall(zesDeviceGetProperties(device, props))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
                else:
                    Node(devNode, "NumSubdevices", props.numSubdevices)
                    Node(devNode, "serialNumber", props.serialNumber)
                    Node(devNode, "boardNumber", props.boardNumber)
                    Node(devNode, "brandName", props.brandName)
                    Node(devNode, "modelName", props.modelName)
                    Node(devNode, "vendorName", props.vendorName)
                    Node(devNode, "driverVersion", props.driverVersion)
                    if args.verbose:
                        Node(devNode, "coreClockRate", props.core.coreClockRate, ("Units", "MHz"))
                        Node(devNode, "maxMemAllocSize", props.core.maxMemAllocSize)
                        Node(devNode, "maxHardwareContexts", props.core.maxHardwareContexts)
                        Node(devNode, "timestampValidBits", props.core.timestampValidBits)
                        Node(devNode, "kernelTimestampValidBits", props.core.kernelTimestampValidBits)
                        Node(devNode, "maxCommandQueuePriority", props.core.maxCommandQueuePriority)
                        Node(devNode, "numThreadsPerEU", props.core.numThreadsPerEU)
                        Node(devNode, "physicalEUSimdWidth", props.core.physicalEUSimdWidth)
                        Node(devNode, "numEUsPerSubslice", props.core.numEUsPerSubslice)
                        Node(devNode, "numSubslicesPerSlice", props.core.numSubslicesPerSlice)
                        Node(devNode, "numSlices", props.core.numSlices)
                        Node(devNode, "timerResolution", props.core.timerResolution)

            if args.show_telemetry:
                nodes = []
                nodes.append(Node(devNode, "ResetReasons", "?"))
                nodes.append(Node(devNode, "RepairStatus", "?"))

                def deviceTelemetry(device=device, nodes=nodes):
                    state = zes_typed_structure(ZES_STRUCTURE_TYPE_DEVICE_STATE)
                    try:
                        zeCall(zesDeviceGetState(device, state))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
                    else:
                        nodes[0].setText(resetReasonsString(state.reset))
                        nodes[1].setText(repairStatusString(state.repaired))

                telemetryClosures.append(deviceTelemetry)

        tempCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumTemperatureSensors(device,tempCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            temperatures = zes_temp_handle_array(tempCount.value())
            zeCall(zesDeviceEnumTemperatureSensors(device,tempCount.cast(), temperatures.cast()))

        if args.enable_critical_temp:
            t, = args.enable_critical_temp
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.enableCritical = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_critical_temp:
            t, = args.disable_critical_temp
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.enableCritical = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t1_low_to_high:
            t, = args.enable_t1_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableLowToHigh = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t1_low_to_high:
            t, = args.disable_t1_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableLowToHigh = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t1_high_to_low:
            t, = args.enable_t1_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableHighToLow = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t1_high_to_low:
            t, = args.disable_t1_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.enableHighToLow = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.set_t1_threshold:
            t,v = args.set_t1_threshold
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold1.threshold = v
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t2_low_to_high:
            t, = args.enable_t2_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableLowToHigh = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t2_low_to_high:
            t, = args.disable_t2_low_to_high
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableLowToHigh = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.enable_t2_high_to_low:
            t, = args.enable_t2_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableHighToLow = True
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.disable_t2_high_to_low:
            t, = args.disable_t2_high_to_low
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.enableHighToLow = False
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")
        if args.set_t2_threshold:
            t,v = args.set_t2_threshold
            if 0 <= t < tempCount.value():
                temp = temperatures[t]
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                    tempConfig.threshold2.threshold = v
                    zeCall(zesTemperatureSetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must provide a valid temperature index")

        if args.show_temp:
            tempTop = Node(devNode, "TemperatureSensors", None)

            for i in range(tempCount.value()):
                temp = temperatures[i]
                tempProps = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_PROPERTIES)
                tempConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_TEMP_CONFIG)
                try:
                    zeCall(zesTemperatureGetProperties(temp, tempProps))
                except NotImplementedError:
                    continue
                except ValueError:
                    logger.reportZeException()
                    continue
                try:
                    zeCall(zesTemperatureGetConfig(temp, tempConfig))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
                tempType = tempTypeString(tempProps.type)
                if tempProps.onSubdevice:
                    tempNode = Node(tempTop, "TemperatureSensor", None, ("Index", i), ("Name", tempType),
                                    ("SubdeviceId", tempProps.subdeviceId))
                else:
                    tempNode = Node(tempTop, "TemperatureSensor", None, ("Index", i), ("Name", tempType))

                if args.show_inventory:
                    Node(tempNode, "MaxTemperature", "%.1f" % tempProps.maxTemperature, ("Units", degC))
                    if tempProps.isCriticalTempSupported:
                        Node(tempNode, "CriticalTempEnabled", bool(tempConfig.enableCritical))
                    if tempProps.isThreshold1Supported:
                        t1Node = Node(tempNode, "Threshold1", None)
                        Node(t1Node, "EnabledLowToHigh", bool(tempConfig.threshold1.enableLowToHigh))
                        Node(t1Node, "EnabledHighToLow", bool(tempConfig.threshold1.enableHighToLow))
                        Node(t1Node, "Threshold", "%.1f" % tempConfig.threshold1.threshold,
                             ("Units", degC))
                    if tempProps.isThreshold2Supported:
                        t2Node = Node(tempNode, "Threshold2", None)
                        Node(t2Node, "EnabledLowToHigh", bool(tempConfig.threshold2.enableLowToHigh))
                        Node(t2Node, "EnabledHighToLow", bool(tempConfig.threshold2.enableHighToLow))
                        Node(t2Node, "Threshold", "%.1f" % tempConfig.threshold2.threshold,
                             ("Units", degC))

                if args.show_telemetry:
                    node = Node(tempNode, "Current", "?", ("Units", degC))

                    def tempTelemetry(temp=temp, node=node, degC=degC):
                        try:
                            tempCurrent = zeCall(zesTemperatureGetState(temp))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node.setText("%.1f" % tempCurrent)

                    telemetryClosures.append(tempTelemetry)

        pwrCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumPowerDomains(device,pwrCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            powers = zes_pwr_handle_array(pwrCount.value())
            zeCall(zesDeviceEnumPowerDomains(device, pwrCount.cast(), powers.cast()))

        if args.set_power or args.set_burst_power or args.set_peak_power:
            sustainedLimit = None
            burstLimit = None
            peakLimit = None
            if args.set_power:
                sustainedLimit = zes_power_sustained_limit_t()
                sustainedLimit.enabled = True
                sustainedLimit.power, remainder = arg.parseMilliwatts(args.set_power)
                sustainedLimit.interval, remainder = arg.parseMilliseconds(remainder)
                if remainder:
                    pr.err("WARNING: Extra set-power arguments ignored")
            if args.set_burst_power:
                burstLimit = zes_power_burst_limit_t()
                burstLimit.enabled = True
                burstLimit.power, remainder = arg.parseMilliwatts(args.set_burst_power)
                if remainder:
                    pr.err("WARNING: Extra set-burst-power arguments ignored")
            if args.set_peak_power:
                peakLimit = zes_power_peak_limit_t()
                peakLimit.powerAC, remainder = arg.parseMilliwatts(args.set_peak_power)
                peakLimit.powerDC, remainder = arg.parseMilliwatts(remainder)
                if remainder:
                    pr.err("WARNING: Extra set-peak-power arguments ignored")
            for i in range(pwrCount.value()):
                pwr = powers[i]
                if args.dry_run:
                    if sustainedLimit:
                        pr("Would set sustained limit to", sustainedLimit.power, "mW,",
                           sustainedLimit.interval, "ms")
                    if burstLimit:
                        pr("Would set burst limit to", burstLimit.power, "mW")
                    if peakLimit:
                        pr("Would set peak AC, DC limits to", peakLimit.powerAC, "mW,",
                           peakLimit.powerDC, "mW")
                else:
                    zeCall(zesPowerSetLimits(pwr, sustainedLimit, burstLimit, peakLimit))

        if args.set_energy_threshold:
            threshold, remainder = arg.parseJoules(args.set_energy_threshold)
            for i in range(pwrCount.value()):
                pwr = powers[i]
                if args.dry_run:
                    pr("Would set energy threshold to", threshold, "J")
                else:
                    zeCall(zesPowerSetEnergyThreshold(pwr, threshold))

        if args.show_power:
            pwrTop = Node(devNode, "PowerDomains", None)

            for i in range(pwrCount.value()):
                pwr = powers[i]
                pwrProps = zes_typed_structure(ZES_STRUCTURE_TYPE_POWER_PROPERTIES)
                zeCall(zesPowerGetProperties(pwr, pwrProps))
                if pwrProps.onSubdevice:
                    pwrNode = Node(pwrTop, "PowerDomain", None, ("Index", i), ("Name", "Subdevice"),
                                      ("SubdeviceId", pwrProps.subdeviceId))
                else:
                    pwrNode = Node(pwrTop, "PowerDomain", None, ("Index", i), ("Name", "Package"))

                if args.show_inventory:
                    if args.verbose:
                        Node(pwrNode, "CanControl", bool(pwrProps.canControl))
                        Node(pwrNode, "ThresholdSupported", bool(pwrProps.isEnergyThresholdSupported))
                        Node(pwrNode, "DefaultLimit", fmtknown(pwrProps.defaultLimit / 1000, "%.3f"),
                             ("Units", "Watts"))
                        Node(pwrNode, "MinLimit", fmtknown(pwrProps.minLimit / 1000, "%.3f"),
                             ("Units", "Watts"))
                        Node(pwrNode, "MaxLimit", fmtknown(pwrProps.maxLimit / 1000, "%.3f"),
                             ("Units", "Watts"))

                    sustainedLimit = zes_power_sustained_limit_t()
                    burstLimit = zes_power_burst_limit_t()
                    peakLimit = zes_power_peak_limit_t()
                    zeCall(zesPowerGetLimits(pwr, sustainedLimit, burstLimit, peakLimit))
                    sustainedNode = Node(pwrNode, "SustainedLimit", None)
                    Node(sustainedNode, "Enabled", bool(sustainedLimit.enabled))
                    Node(sustainedNode, "Power", "%.3f" % (sustainedLimit.power / 1000),
                         ("Units", "Watts"))
                    Node(sustainedNode, "Interval", "%.3f" % (sustainedLimit.interval / 1000),
                         ("Units", "sec"))
                    burstNode = Node(pwrNode, "BurstLimit", None)
                    Node(burstNode, "Enabled", bool(burstLimit.enabled))
                    Node(burstNode, "Power", "%.3f" % (burstLimit.power / 1000), ("Units", "Watts"))
                    peakNode = Node(pwrNode, "PeakLimit", None)
                    Node(peakNode, "Power", "%.3f" % (peakLimit.powerAC / 1000), ("Units", "Watts"))
                    if peakLimit.powerDC > 0:
                        Node(peakNode, "PowerOnDC", "%.3f" % (peakLimit.powerDC / 1000),
                             ("Units", "Watts"))

                if args.show_telemetry:
                    pwrCounter = zes_power_energy_counter_t()
                    pwrThreshold = zes_energy_threshold_t()
                    zeCall(zesPowerGetEnergyCounter(pwr, pwrCounter))
                    nodes = []
                    nodes.append(Node(pwrNode, "CurrentPower", "?", ("Units", "Watts")))
                    nodes.append(Node(pwrNode, "MonitorProcess", "?"))
                    nodes.append(Node(pwrNode, "EnergyThreshold", "?", ("Units", "Joules")))

                    def pwrTelemetry(pwr=pwr, pwrCounter=pwrCounter, pwrThreshold=pwrThreshold, node=nodes):
                        oldEnergy, oldTimestamp = pwrCounter.energy, pwrCounter.timestamp
                        zeCall(zesPowerGetEnergyCounter(pwr, pwrCounter))
                        deltaE = pwrCounter.energy - oldEnergy
                        deltaT = pwrCounter.timestamp - oldTimestamp
                        if deltaT > 0:
                            watts = "%.3f" % (float(deltaE) / deltaT)
                        else:
                            watts = "?"
                        node[0].setText(watts)
                        zeCall(zesPowerGetEnergyThreshold(pwr, pwrThreshold))
                        if pwrThreshold.enable:
                            if pwrThreshold.processId != 0xffffffff:
                                node[1].setText(pwrThreshold.processId)
                            else:
                                node[1].setText("Unknown")
                        else:
                            node[1].setText("None")
                        node[2].setText("%.3f" % pwrThreshold.threshold)

                    telemetryClosures.append(pwrTelemetry)
                    pollDelayRequired = True

        freqCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFrequencyDomains(device, freqCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            frequencies = zes_freq_handle_array(freqCount.value())
            zeCall(zesDeviceEnumFrequencyDomains(device, freqCount.cast(), frequencies.cast()))

        if args.set_freq or args.reset_freq:
            for i in range(freqCount.value()):
                freqRange = zes_freq_range_t()
                if args.reset_freq:
                    freqRange.min = 0
                    freqRange.max = 0
                if args.set_freq:
                    freqRange.min, remainder = arg.parseMHz(args.set_freq)
                    if remainder:
                        freqRange.max, remainder = arg.parseMHz(remainder)
                        if remainder:
                            pr.err("WARNING: Extra set-freq arguments ignored")
                    else:
                        freqRange.max = freqRange.min
                freq = frequencies[i]
                if args.dry_run:
                    pr("Would set frequency range to", freqRange.min, "MHz -", freqRange.max, "MHz")
                else:
                    zeCall(zesFrequencySetRange(freq, freqRange))

        if args.show_freq:
            freqTop = Node(devNode, "FrequencyDomains", None)

            for i in range(freqCount.value()):
                freq = frequencies[i]
                freqProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_PROPERTIES)
                zeCall(zesFrequencyGetProperties(freq, freqProps))
                freqType = freqTypeString(freqProps.type)
                if freqProps.onSubdevice:
                    freqNode = Node(freqTop, "FrequencyDomain", None, ("Index", i), ("Name", freqType),
                                       ("SubdeviceId", freqProps.subdeviceId))
                else:
                    freqNode = Node(freqTop, "FrequencyDomain", None, ("Index", i), ("Name", freqType))

                if args.show_inventory:
                    if args.verbose:
                        Node(freqNode, "CanControl", bool(freqProps.canControl))
                        Node(freqNode, "ThrottleEventSupported",
                             bool(freqProps.isThrottleEventSupported))
                    availFreqsNode = Node(freqNode, "AvailableFrequencies", None)
                    Node(availFreqsNode, "Min", "%.1f" % freqProps.min, ("Units", "MHz"))
                    Node(availFreqsNode, "Max", "%.1f" % freqProps.max, ("Units", "MHz"))
                    if args.verbose:
                        clockCount = uint32_ptr()
                        try:
                            zeCall(zesFrequencyGetAvailableClocks(freq, clockCount.cast(), None))
                        except:
                            pass
                        else:
                            clockFreqs = double_array(clockCount.value())
                            zeCall(zesFrequencyGetAvailableClocks(freq, clockCount.cast(), clockFreqs.cast()))
                        for clk in range(clockCount.value()):
                            clockFreq = clockFreqs[clk]
                            Node(availFreqsNode, "AvailableFrequency", "%.1f" % clockFreq,
                                 ("Units", "MHz"))

                    freqRange = zes_freq_range_t()
                    zeCall(zesFrequencyGetRange(freq, freqRange))
                    rangeFreqsNode = Node(freqNode, "FrequencyRange", None)
                    Node(rangeFreqsNode, "Min", "%.1f" % freqRange.min, ("Units", "MHz"))
                    Node(rangeFreqsNode, "Max", "%.1f" % freqRange.max, ("Units", "MHz"))

                if args.show_telemetry:
                    freqState = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_STATE)
                    freqThrottle = zes_freq_throttle_time_t()
                    try:
                        zeCall(zesFrequencyGetThrottleTime(freq, freqThrottle))
                    except NotImplementedError:
                        freqThrottle = None
                    except ValueError:
                        logger.reportZeException()
                    nodes = []
                    nodes.append(Node(freqNode, "RequestedFrequency", "?", ("Units", "MHz")))
                    nodes.append(Node(freqNode, "ActualFrequency", "?", ("Units", "MHz")))
                    nodes.append(Node(freqNode, "ThrottleReasons", "?"))
                    nodes.append(Node(freqNode, "ThrottleTime", "?", ("Units", "%")))
                    if args.verbose:
                        nodes.append(Node(freqNode, "CurrentVoltage", "?", ("Units", "Volts")))
                        nodes.append(Node(freqNode, "Efficient", "?", ("Units", "MHz")))
                        nodes.append(Node(freqNode, "MaximumTDP", "?", ("Units", "MHz")))

                    def freqTelemetry(freq=freq, freqState=freqState, freqThrottle=freqThrottle,
                                      node=nodes, verbose=args.verbose):
                        throttlePercent = "?"
                        if freqThrottle:
                            oldHeld, oldTimestamp = freqThrottle.throttleTime, freqThrottle.timestamp
                            try:
                                zeCall(zesFrequencyGetThrottleTime(freq, freqThrottle))
                            except:
                                logger.reportZeException()
                            else:
                                deltaH = freqThrottle.throttleTime - oldHeld
                                deltaT = freqThrottle.timestamp - oldTimestamp
                                if deltaT > 0:
                                    throttlePercent = "%.0f" % (100.0 * deltaH / deltaT)
                                else:
                                    throttlePercent = "?"
                        zeCall(zesFrequencyGetState(freq, freqState))
                        node[0].setText(fmtknown(freqState.request))
                        node[1].setText(fmtknown(freqState.actual))
                        node[2].setText(throttleReasonsString(freqState.throttleReasons))
                        node[3].setText(throttlePercent)
                        if verbose:
                            node[4].setText(fmtknown(freqState.currentVoltage))
                            node[5].setText(fmtknown(freqState.efficient))
                            node[6].setText(fmtknown(freqState.tdp))

                    telemetryClosures.append(freqTelemetry)
                    pollDelayRequired = True

        # TODO: Use generalized parsing methods that support units

        if args.set_oc_freq:
            idxStr, frqStr = args.set_oc_freq
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                frqMHz = float(frqStr)
            except:
                pr.fail("Usage: --set-oc-freq IDX FREQ")
            if args.dry_run:
                pr("Would set oc", i, "frequency target to", frqMHz, "MHz")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    frqMHz = util.saturate(frqMHz, 0.0, ocCaps.maxOcFrequency)
                    zeCall(zesFrequencyOcSetFrequencyTarget(freq, frqMHz))
                except:
                    pr.fail("--set-oc-freq not supported")

        if args.set_oc_volts:
            idxStr, vTargetStr, vOffsetStr = args.set_oc_volts
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                vTarget = float(vTargetStr)
                vOffset = float(vOffsetStr)
            except:
                pr.fail("Usage: --set-oc-volts IDX VOLTAGE_TARGET VOLTAGE_OFFSET")
            if args.dry_run:
                pr("Would set oc", i, "voltage target to", vTarget, "V, offset", vOffset, "V")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    vTarget = util.saturate(vTarget, 0.0, ocCaps.maxOcVoltage)
                    vOffset = util.saturate(vOffset, ocCaps.minOcVoltageOffset, ocCaps.maxOcVoltageOffset)
                    zeCall(zesFrequencyOcSetVoltageTarget(freq, vTarget, vOffset))
                except:
                    pr.fail("--set-oc-volts not supported")

        if args.set_oc_off:
            idxStr, = args.set_oc_off
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-off IDX")
            if args.dry_run:
                pr("Would set oc", i, "mode to OFF")
            else:
                try:
                    freq = frequencies[i]
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_OFF))
                except:
                    pr.fail("--set-oc-off not supported")

        if args.set_oc_override:
            idxStr, = args.set_oc_override
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-override IDX")
            if args.dry_run:
                pr("Would set oc", i, "mode to OVERRIDE")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_OVERRIDE))
                except:
                    pr.fail("--set-oc-override not supported")

        if args.set_oc_interpolate:
            idxStr, = args.set_oc_interpolate
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-interpolate IDX")
            if args.dry_run:
                pr("Would set oc", i, "mode to INTERPOLATIVE")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_INTERPOLATIVE))
                except:
                    pr.fail("--set-oc-interpolate not supported")

        if args.set_oc_fixed:
            idxStr, = args.set_oc_fixed
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
            except:
                pr.fail("Usage: --set-oc-interpolate IDX")
            if args.dry_run:
                pr("Would set oc", i, "mode to FIXED")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported and ocCaps.isFixedModeSupported
                    zeCall(zesFrequencyOcSetMode(freq, ZES_OC_MODE_FIXED))
                except:
                    pr.fail("--set-oc-interpolate not supported")

        if args.set_oc_max_current:
            idxStr, iccStr = args.set_oc_max_current
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                iccAmps = float(iccStr)
            except:
                pr.fail("Usage: --set-oc-max-current IDX MAX_AMPS")
            if args.dry_run:
                pr("Would set oc", i, "maximum current to", iccAmps, "MHz")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported and ocCaps.isIccMaxSupported
                    zeCall(zesFrequencyOcSetIccMax(freq, iccAmps))
                except:
                    pr.fail("--set-oc-max-current not supported")

        if args.set_oc_max_temp:
            idxStr, tempStr = args.set_oc_max_temp
            try:
                i = int(idxStr)
                assert 0 <= i < freqCount.value()
                tempC = float(tempStr)
            except:
                pr.fail("Usage: --set-oc-max-temp IDX MAX_DEG_C")
            if args.dry_run:
                pr("Would set oc", i, "maximum temperature to", tempC, "MHz")
            else:
                try:
                    freq = frequencies[i]
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                    assert ocCaps.isOcSupported and ocCaps.isTjMaxSupported
                    zeCall(zesFrequencyOcSetTjMax(freq, tempC))
                except:
                    pr.fail("--set-oc-max-temp not supported")

        if args.show_oc:
            ocTop = Node(devNode, "OverclockDomains", None)

            for i in range(freqCount.value()):
                freq = frequencies[i]
                ocNode = None
                try:
                    freqProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FREQ_PROPERTIES)
                    zeCall(zesFrequencyGetProperties(freq, freqProps))
                    ocCaps = zes_typed_structure(ZES_STRUCTURE_TYPE_OC_CAPABILITIES)
                    zeCall(zesFrequencyOcGetCapabilities(freq, ocCaps))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
                else:
                    freqType = freqTypeString(freqProps.type)
                    if freqProps.onSubdevice:
                        ocNode = Node(ocTop, "OverclockDomain", None, ("Index", i), ("Name", freqType),
                                           ("SubdeviceId", freqProps.subdeviceId))
                    else:
                        ocNode = Node(ocTop, "OverclockDomain", None, ("Index", i), ("Name", freqType))

                if ocNode and args.show_inventory:
                    try:
                        mode = zeCall(zesFrequencyOcGetMode(freq))
                    except:
                        mode = ZES_OC_MODE_OFF
                    Node(ocNode, "OverclockingMode", ocModeString(mode))
                    Node(ocNode, "isOcSupported", bool(ocCaps.isOcSupported))
                    Node(ocNode, "maxFactoryDefaultFrequency", "%.1f" % ocCaps.maxFactoryDefaultFrequency,
                         ("Units", "MHz"))
                    Node(ocNode, "maxFactoryDefaultVoltage", "%.1f" % ocCaps.maxFactoryDefaultVoltage,
                         ("Units", "V"))
                    Node(ocNode, "maxOcFrequency", "%.1f" % ocCaps.maxOcFrequency, ("Units", "MHz"))
                    Node(ocNode, "minOcVoltageOffset", "%.1f" % ocCaps.minOcVoltageOffset, ("Units", "V"))
                    Node(ocNode, "maxOcVoltageOffset", "%.1f" % ocCaps.maxOcVoltageOffset, ("Units", "V"))
                    Node(ocNode, "maxOcVoltage", "%.1f" % ocCaps.maxOcVoltage, ("Units", "V"))
                    Node(ocNode, "isTjMaxSupported", bool(ocCaps.isTjMaxSupported))
                    Node(ocNode, "isIccMaxSupported", bool(ocCaps.isIccMaxSupported))
                    Node(ocNode, "isHighVoltModeCapable", bool(ocCaps.isHighVoltModeCapable))
                    Node(ocNode, "isHighVoltModeEnabled", bool(ocCaps.isHighVoltModeEnabled))
                    Node(ocNode, "isExtendedModeSupported", bool(ocCaps.isExtendedModeSupported))
                    Node(ocNode, "isFixedModeSupported", bool(ocCaps.isFixedModeSupported))

                    if ocCaps.isOcSupported:
                        try:
                            frq = zeCall(zesFrequencyOcGetFrequencyTarget(freq))
                            ocFreq = "%.1f" % frq
                        except:
                            ocFreq = "?"
                        Node(ocNode, "CurrentOcFrequencyTarget", ocFreq, ("Units", "MHz"))
                        try:
                            tgt, off = zeCall(zesFrequencyOcGetVoltageTarget(freq))
                            vTarget, vOffset = "%.1f" % tgt, "%.1f" % off
                        except:
                            vTarget, vOffset = "?", "?"
                        Node(ocNode, "CurrentOcVoltageTarget", vTarget, ("Units", "V"))
                        Node(ocNode, "CurrentOcVoltageOffset", vOffset, ("Units", "V"))

                    if ocCaps.isIccMaxSupported:
                        try:
                            icc = zeCall(zesFrequencyOcGetIccMax(freq))
                            iccMax = "%.1f" % icc
                        except:
                            iccMax = "?"
                        Node(ocNode, "OcCurrentLimit", iccMax, ("Units", "A"))

                    if ocCaps.isTjMaxSupported:
                        try:
                            tj = zeCall(zesFrequencyOcGetTjMax(freq))
                            tjMax = "%.1f" % tj
                        except:
                            tjMax = "?"
                        Node(ocNode, "OcTemperatureLimit", tjMax, ("Units", degC))

        engCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumEngineGroups(device, engCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            engs = zes_engine_handle_array(engCount.value())
            zeCall(zesDeviceEnumEngineGroups(device, engCount.cast(), engs.cast()))

        if args.show_util:
            engTop = Node(devNode, "EngineGroups", None)

            for i in range(engCount.value()):
                eng = engs[i]
                engProps = zes_typed_structure(ZES_STRUCTURE_TYPE_ENGINE_PROPERTIES)
                zeCall(zesEngineGetProperties(eng, engProps))
                engType = engTypeString(engProps.type)

                if engProps.onSubdevice:
                    engNode = Node(engTop, "EngineGroup", None, ("Index", i), ("Name", engType),
                                      ("SubdeviceId", engProps.subdeviceId))
                else:
                    engNode = Node(engTop, "EngineGroup", None, ("Index", i), ("Name", engType))

                if args.show_telemetry:
                    utilStats = zes_engine_stats_t()
                    try:
                        zeCall(zesEngineGetActivity(eng, utilStats))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
                    else:
                        node = Node(engNode, "Activity", "?", ("Units", "%"))

                        def utilTelemetry(eng=eng, utilStats=utilStats, node=node):
                            oldActive, oldTimestamp = utilStats.activeTime, utilStats.timestamp
                            zeCall(zesEngineGetActivity(eng, utilStats))
                            deltaA = utilStats.activeTime - oldActive
                            deltaT = utilStats.timestamp - oldTimestamp
                            if deltaT > 0:
                                util = "%.0f" % (100.0 * deltaA / deltaT)
                            else:
                                util = "?"
                            node.setText(util)

                        telemetryClosures.append(utilTelemetry)
                        pollDelayRequired = True

        memCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumMemoryModules(device, memCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            mems = zes_mem_handle_array(memCount.value())
            zeCall(zesDeviceEnumMemoryModules(device, memCount.cast(), mems.cast()))

        if args.show_mem:
            memTop = Node(devNode, "MemoryModules", None)

            for i in range(memCount.value()):
                mem = mems[i]
                memProps = zes_typed_structure(ZES_STRUCTURE_TYPE_MEM_PROPERTIES)
                zeCall(zesMemoryGetProperties(mem, memProps))
                memType = memTypeString(memProps.type)

                if memProps.onSubdevice:
                    memNode = Node(memTop, "MemoryModule", None, ("Index", i), ("Name", memType),
                                      ("SubdeviceId", memProps.subdeviceId))
                else:
                    memNode = Node(memTop, "MemoryModule", None, ("Index", i), ("Name", memType))

                if args.show_inventory:
                    Node(memNode, "Location", memLocString(memProps.location))
                    Node(memNode, "PhysicalSize", memProps.physicalSize, ("Units", "Bytes"))
                    Node(memNode, "BusWidth", knownvalue(memProps.busWidth))
                    Node(memNode, "NumChannels", knownvalue(memProps.numChannels))

                if args.show_telemetry:
                    memCounter = zes_mem_bandwidth_t()
                    memState = zes_typed_structure(ZES_STRUCTURE_TYPE_MEM_STATE)
                    try:
                        zeCall(zesMemoryGetBandwidth(mem, memCounter))
                        zeCall(zesMemoryGetState(mem, memState))
                    except:
                        pass
                    nodes = []
                    nodes.append(Node(memNode, "Health", "?"))
                    nodes.append(Node(memNode, "Free", "?", ("Units", "Bytes")))
                    nodes.append(Node(memNode, "Utilized", "?", ("Units", "%")))
                    nodes.append(Node(memNode, "ReadThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(memNode, "WriteThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(memNode, "Bandwidth", "?", ("Units", "%")))

                    def memTelemetry(mem=mem, memState=memState, memCounter=memCounter, node=nodes):
                        oldRead, oldWrite = memCounter.readCounter, memCounter.writeCounter
                        oldTimestamp = memCounter.timestamp
                        try:
                            zeCall(zesMemoryGetState(mem, memState))
                        except:
                            pass
                        else:
                            node[0].setText(memHealthString(memState.health))
                            node[1].setText(memState.free)
                            node[2].setText("%.1f" % (100.0 * (memState.size - memState.free) / memState.size))

                        try:
                            zeCall(zesMemoryGetBandwidth(mem, memCounter))
                        except:
                            pass
                        else:
                            deltaR = memCounter.readCounter - oldRead
                            deltaW = memCounter.writeCounter - oldWrite
                            deltaT = memCounter.timestamp - oldTimestamp
                            maxBW = 1.0 * memCounter.maxBandwidth
                            if deltaT > 0:
                                readThroughput = "%.1f" % (1e6 * deltaR / deltaT)
                                writeThroughput = "%.1f" % (1e6 * deltaW / deltaT)
                                if maxBW > 0:
                                    memBandwidth = "%.1f" % (1e8 * (deltaR + deltaW) / (maxBW * deltaT))
                                else:
                                    memBandwidth = "?"
                            else:
                                readThroughput = "?"
                                writeThroughput = "?"
                                memBandwidth = "?"

                            node[3].setText(readThroughput)
                            node[4].setText(writeThroughput)
                            node[5].setText(memBandwidth)

                    telemetryClosures.append(memTelemetry)
                    pollDelayRequired = True

        showPci = False
        if args.show_pci:
            pciProps = zes_typed_structure(ZES_STRUCTURE_TYPE_PCI_PROPERTIES)
            try:
                zeCall(zesDevicePciGetProperties(device, pciProps))
            except NotImplementedError:
                pass
            except ValueError:
                logger.reportZeException()
            else:
                showPci = True

        if showPci:
            pciTop = Node(devNode, "PCI", None)
            if args.show_inventory:
                props = zes_typed_structure(ZES_STRUCTURE_TYPE_DEVICE_PROPERTIES)
                zeCall(zesDeviceGetProperties(device, props))
                Node(pciTop, "DeviceId", hex(props.core.deviceId))
                pciAddr = pciProps.address
                address = "%02x:%02x.%x" % (pciAddr.bus, pciAddr.device, pciAddr.function)
                if pciAddr.domain != 0:
                    address = ("%04x:" % pciAddr.domain) + address
                Node(pciTop, "Address", address)
                Node(pciTop, "MaxGen", knownvalue(pciProps.maxSpeed.gen))
                Node(pciTop, "MaxLanes", knownvalue(pciProps.maxSpeed.width))
                Node(pciTop, "MaxBandwidth", fmtknown(pciProps.maxSpeed.maxBandwidth),
                     ("Units", "Bytes/s"))
                Node(pciTop, "HaveBandwidthCounters", pciProps.haveBandwidthCounters)
                Node(pciTop, "HavePacketCounters", pciProps.havePacketCounters)
                Node(pciTop, "HaveReplayCounters", pciProps.haveReplayCounters)

                if args.verbose:
                    barTop = Node(pciTop, "Bars", None)
                    barCount = uint32_ptr()
                    zeCall(zesDevicePciGetBars(device, barCount.cast(), None))
                    bars = zes_typed_array(ZES_STRUCTURE_TYPE_PCI_BAR_PROPERTIES, barCount.value())
                    zeCall(zesDevicePciGetBars(device, barCount.cast(), bars.cast()))

                    for i in range(barCount.value()):
                        bar = bars[i]
                        barName = barTypeString(bar.type)
                        barNode = Node(barTop, "Bar", None, ("Name", barName))
                        Node(barNode, "Index", bar.index)
                        Node(barNode, "Base", "0x%016x" % bar.base)
                        Node(barNode, "Size", "0x%016x" % bar.size)

            showPciTelemetry = False
            if args.show_telemetry:
                tmp = zes_typed_structure(ZES_STRUCTURE_TYPE_PCI_STATE)
                try:
                    zeCall(zesDevicePciGetState(device, tmp))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
                else:
                    showPciTelemetry = True
                del tmp

            if showPciTelemetry:
                have = { 'bw': pciProps.haveBandwidthCounters, 'pkt' : pciProps.havePacketCounters,
                         'replay' : pciProps.haveReplayCounters }
                pciState = zes_typed_structure(ZES_STRUCTURE_TYPE_PCI_STATE)
                pciCounter = zes_pci_stats_t()
                zeCall(zesDevicePciGetStats(device, pciCounter))

                nodes = []
                nodes.append(Node(pciTop, "Status", "?"))
                nodes.append(Node(pciTop, "QualityIssues", "?"))
                nodes.append(Node(pciTop, "StabilityIssues", "?"))
                nodes.append(Node(pciTop, "CurrentGen", "?"))
                nodes.append(Node(pciTop, "CurrentLanes", "?"))
                nodes.append(Node(pciTop, "CurrentBandwidth", "?", ("Units", "Bytes/s")))
                if have['bw']:
                    nodes.append(Node(pciTop, "RxThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(pciTop, "TxThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(pciTop, "Utilization", "?", ("Units", "%")))
                if have['pkt']:
                    nodes.append(Node(pciTop, "PacketRate", "?"))
                    if have['replay']:
                        nodes.append(Node(pciTop, "ReplayRate", "?", ("Units", "%")))
                elif have['replay']:
                        nodes.append(Node(pciTop, "ReplayRate", "?"))

                def pciTelemetry(device=device, have=have, pciState=pciState, pciCounter=pciCounter,
                                 node=nodes):
                    oldRx, oldTx = pciCounter.rxCounter, pciCounter.txCounter
                    oldPacket = pciCounter.packetCounter
                    oldReplay = pciCounter.replayCounter
                    oldTimestamp = pciCounter.timestamp
                    zeCall(zesDevicePciGetState(device, pciState))
                    zeCall(zesDevicePciGetStats(device, pciCounter))
                    deltaRx = pciCounter.rxCounter - oldRx
                    deltaTx = pciCounter.txCounter - oldTx
                    deltaPacket = pciCounter.packetCounter - oldPacket
                    deltaReplay = pciCounter.replayCounter - oldReplay
                    deltaT = pciCounter.timestamp - oldTimestamp
                    maxBW = 1.0 * pciCounter.speed.maxBandwidth
                    if deltaT > 0:
                        rxThroughput = "%.1f" % (1e6 * deltaRx / deltaT)
                        txThroughput = "%.1f" % (1e6 * deltaTx / deltaT)
                        if maxBW > 0:
                            pciUtilization = "%.1f" % (1e8 * (deltaRx + deltaTx) / (maxBW * deltaT))
                        else:
                            pciUtilization = "?"
                    else:
                        rxThroughput = "?"
                        txThroughput = "?"
                        pciUtilization = "?"

                    if have['pkt'] and deltaPacket > 0 and deltaT > 0:
                        packetRate = "%.1f" % (deltaPacket / deltaT)
                        replayRate = "%.1f" % (100.0 * deltaReplay / deltaPacket)
                    elif have['replay'] and deltaReplay > 0 and deltaT > 0:
                        packetRate = "?"
                        replayRate = "%.1f" % (deltaReplay / deltaT)
                    else:
                        packetRate = "?"
                        replayRate = "?"

                    if (pciState.speed.gen != pciCounter.speed.gen or
                        pciState.speed.width != pciCounter.speed.width or
                        pciState.speed.maxBandwidth != pciCounter.speed.maxBandwidth):

                        pr.err("WARNING: speed mismatch between PCI state/stats")

                    node[0].setText(pciLinkStatusString(pciState.status))
                    node[1].setText(pciQualityIssuesString(pciState.qualityIssues))
                    node[2].setText(pciStabilityIssuesString(pciState.stabilityIssues))
                    node[3].setText(knownvalue(pciCounter.speed.gen))
                    node[4].setText(knownvalue(pciCounter.speed.width))
                    node[5].setText(fmtknown(pciCounter.speed.maxBandwidth))
                    i = 6
                    if have['bw']:
                        node[i].setText(rxThroughput)
                        node[i+1].setText(txThroughput)
                        node[i+2].setText(pciUtilization)
                        i += 3
                    if have['pkt']:
                        node[i].setText(packetRate)
                        i += 1
                    if have['replay']:
                        node[i].setText(replayRate)

                telemetryClosures.append(pciTelemetry)
                pollDelayRequired = True

        portCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            ports = zes_fabric_port_handle_array(portCount.value())
            zeCall(zesDeviceEnumFabricPorts(device, portCount.cast(), ports.cast()))

        if (args.enable_fabric_ports is not None or args.disable_fabric_ports is not None or
            args.enable_beaconing is not None or args.disable_beaconing is not None):

            if args.enable_fabric_ports is None:
                enable_ports = []
            elif args.enable_fabric_ports == []:
                enable_ports = list(range(portCount.value()))
            else:
                enable_ports = args.enable_fabric_ports

            if args.disable_fabric_ports is None:
                disable_ports = []
            elif args.disable_fabric_ports == []:
                disable_ports = list(range(portCount.value()))
            else:
                disable_ports = args.disable_fabric_ports

            if args.enable_beaconing is None:
                enable_beacon = []
            elif args.enable_beaconing == []:
                enable_beacon = list(range(portCount.value()))
            else:
                enable_beacon = args.enable_beaconing

            if args.disable_beaconing is None:
                disable_beacon = []
            elif args.disable_beaconing == []:
                disable_beacon = list(range(portCount.value()))
            else:
                disable_beacon = args.disable_beaconing

            affected_ports = enable_ports + disable_ports + enable_beacon + disable_beacon

            for i in range(portCount.value()):
                if i in affected_ports:
                    port = ports[i]
                    portConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG)
                    zeCall(zesFabricPortGetConfig(port, portConfig))
                    if i in enable_ports:
                        portConfig.enabled = True
                    if i in disable_ports:
                        portConfig.enabled = False
                    if i in enable_beacon:
                        portConfig.beaconing = True
                    if i in disable_beacon:
                        portConfig.beaconing = False
                    zeCall(zesFabricPortSetConfig,port, portConfig)

        if args.show_fabric_ports:
            portTop = Node(devNode, "FabricPorts", None)

            for i in range(portCount.value()):
                port = ports[i]
                portProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_PROPERTIES)
                zeCall(zesFabricPortGetProperties(port, portProps))

                if portProps.onSubdevice:
                    portNode = Node(portTop, "FabricPort", None, ("Index", i),
                                    ("SubdeviceId", portProps.subdeviceId))
                else:
                    portNode = Node(portTop, "FabricPort", None, ("Index", i))

                if args.show_inventory:
                    portLinkType = zes_fabric_link_type_t()
                    portConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_CONFIG)

                    zeCall(zesFabricPortGetLinkType(port, portLinkType))
                    zeCall(zesFabricPortGetConfig(port, portConfig))

                    Node(portNode, "Model", portProps.model)
                    Node(portNode, "PhysicalAttachmentType", portLinkType.desc)
                    Node(portNode, "FabricId", portProps.portId.fabricId)
                    Node(portNode, "AttachId", portProps.portId.attachId)
                    Node(portNode, "PortNumber", portProps.portId.portNumber)
                    Node(portNode, "MaxRxBitrate", portProps.maxRxSpeed.bitRate, ("Units", "Bits/sec"))
                    Node(portNode, "MaxRxWidth", portProps.maxRxSpeed.width)
                    Node(portNode, "MaxTxBitrate", portProps.maxTxSpeed.bitRate, ("Units", "Bits/sec"))
                    Node(portNode, "MaxTxWidth", portProps.maxTxSpeed.width)
                    Node(portNode, "Enabled", bool(portConfig.enabled))
                    Node(portNode, "Beaconing", bool(portConfig.beaconing))

                if args.show_telemetry:
                    portState = zes_typed_structure(ZES_STRUCTURE_TYPE_FABRIC_PORT_STATE)
                    portCounter = zes_fabric_port_throughput_t()
                    zeCall(zesFabricPortGetThroughput(port, portCounter))
                    nodes = []
                    nodes.append(Node(portNode, "Status", "?"))
                    nodes.append(Node(portNode, "QualityIssues", "?"))
                    nodes.append(Node(portNode, "FailureReasons", "?"))
                    nodes.append(Node(portNode, "RemoteFabricId", "?"))
                    nodes.append(Node(portNode, "RemoteAttachId", "?"))
                    nodes.append(Node(portNode, "RemotePortNumber", "?"))
                    nodes.append(Node(portNode, "CurrentRxBitrate", "?", ("Units", "Bits/sec")))
                    nodes.append(Node(portNode, "CurrentRxWidth", "?"))
                    nodes.append(Node(portNode, "CurrentTxBitrate", "?", ("Units", "Bits/sec")))
                    nodes.append(Node(portNode, "CurrentTxWidth", "?"))
                    nodes.append(Node(portNode, "RxThroughput", "?", ("Units", "Bytes/s")))
                    nodes.append(Node(portNode, "TxThroughput", "?", ("Units", "Bytes/s")))

                    def portTelemetry(port=port, portState=portState, portCounter=portCounter,
                                      node=nodes):
                        oldRx, oldTx = portCounter.rxCounter, portCounter.txCounter
                        oldTimestamp = portCounter.timestamp
                        zeCall(zesFabricPortGetState(port, portState))
                        zeCall(zesFabricPortGetThroughput(port, portCounter))

                        deltaRx = portCounter.rxCounter - oldRx
                        deltaTx = portCounter.txCounter - oldTx
                        deltaT = portCounter.timestamp - oldTimestamp
                        if deltaT > 0:
                            rxThroughput = "%.1f" % (1e6 * deltaRx / deltaT)
                            txThroughput = "%.1f" % (1e6 * deltaTx / deltaT)
                        else:
                            rxThroughput = "?"
                            txThroughput = "?"

                        node[0].setText(portStatusString(portState.status))
                        node[1].setText(portQualityIssuesString(portState.qualityIssues))
                        node[2].setText(portFailureReasonsString(portState.failureReasons))
                        node[3].setText(portState.remotePortId.fabricId)
                        node[4].setText(portState.remotePortId.attachId)
                        node[5].setText(portState.remotePortId.portNumber)
                        node[6].setText(portState.rxSpeed.bitRate)
                        node[7].setText(portState.rxSpeed.width)
                        node[8].setText(portState.txSpeed.bitRate)
                        node[9].setText(portState.txSpeed.width)
                        node[10].setText(rxThroughput)
                        node[11].setText(txThroughput)

                    telemetryClosures.append(portTelemetry)
                    pollDelayRequired = True

        edomCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumRasErrorSets(device, edomCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            edoms = zes_ras_handle_array(edomCount.value())
            zeCall(zesDeviceEnumRasErrorSets(device, edomCount.cast(), edoms.cast()))

        if args.set_error_thresholds:
            i,thresholds = args.set_error_thresholds[0], args.set_error_thresholds[1:]
            try:
                assert 0 <= i < edomCount.value()
                assert 0 < len(thresholds) <= ZES_MAX_RAS_ERROR_CATEGORY_COUNT + 1
            except:
                pr.fail("ERROR: must specify a valid error domain index and 1 to",
                        ZES_MAX_RAS_ERROR_CATEGORY_COUNT + 1,"thresholds")
            else:
                if args.dry_run:
                    pr("Would set error domain", i, "thresholds to", thresholds)
                else:
                    try:
                        ras = edoms[i]
                        rasConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_CONFIG)
                        if len(thresholds) < ZES_MAX_RAS_ERROR_CATEGORY_COUNT + 1:
                            zeCall(zesRasGetConfig(ras, rasConfig))
                        else:
                            rasConfig.totalThreshold = thresholds.pop()
                        for t in range(len(thresholds)):
                            ras_category_set(rasConfig.detailedThresholds, t, thresholds[t])
                        zeCall(zesRasSetConfig(ras, rasConfig))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()

        if args.show_errors:
            rasTop = Node(devNode, "ErrorDomains", None)

            for i in range(edomCount.value()):
                ras = edoms[i]
                rasProps = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_PROPERTIES)
                try:
                    zeCall(zesRasGetProperties(ras, rasProps))
                except NotImplementedError:
                    continue
                except ValueError:
                    logger.reportZeException()
                    continue
                rasType = rasTypeString(rasProps.type)

                if rasProps.onSubdevice:
                    rasNode = Node(rasTop, "ErrorDomain", None, ("Index", i), ("Name", rasType),
                                      ("SubdeviceId", rasProps.subdeviceId))
                else:
                    rasNode = Node(rasTop, "ErrorDomain", None, ("Index", i), ("Name", rasType))

                if args.show_inventory:
                    try:
                        rasConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_CONFIG)
                        zeCall(zesRasGetConfig(ras, rasConfig))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
                    else:
                        thresholdNode = Node(rasNode, "Thresholds", None)
                        thresholds = rasConfig.detailedThresholds

                        Node(thresholdNode, "Resets", ras_category(thresholds, ZES_RAS_ERROR_CAT_RESET))
                        Node(thresholdNode, "ProgrammingErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_PROGRAMMING_ERRORS))
                        Node(thresholdNode, "DriverErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_DRIVER_ERRORS))
                        Node(thresholdNode, "ComputeErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_COMPUTE_ERRORS))
                        Node(thresholdNode, "NonComputeErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_NON_COMPUTE_ERRORS))
                        Node(thresholdNode, "CacheErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_CACHE_ERRORS))
                        Node(thresholdNode, "DisplayErrors",
                             ras_category(thresholds, ZES_RAS_ERROR_CAT_DISPLAY_ERRORS))
                        Node(thresholdNode, "TotalErrors", rasConfig.totalThreshold)

                if args.show_telemetry:
                    rasState = zes_typed_structure(ZES_STRUCTURE_TYPE_RAS_STATE)

                    nodes = []
                    nodes.append(Node(rasNode, "Resets", "?"))
                    nodes.append(Node(rasNode, "ProgrammingErrors", "?"))
                    nodes.append(Node(rasNode, "DriverErrors", "?"))
                    nodes.append(Node(rasNode, "ComputeErrors", "?"))
                    nodes.append(Node(rasNode, "NonComputeErrors", "?"))
                    nodes.append(Node(rasNode, "CacheErrors", "?"))
                    nodes.append(Node(rasNode, "DisplayErrors", "?"))

                    def rasTelemetry(ras=ras, node=nodes, rasState=rasState):
                        try:
                            zeCall(zesRasGetState(ras, args.clear_errors, rasState))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_RESET))
                            node[1].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_PROGRAMMING_ERRORS))
                            node[2].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_DRIVER_ERRORS))
                            node[3].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_COMPUTE_ERRORS))
                            node[4].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_NON_COMPUTE_ERRORS))
                            node[5].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_CACHE_ERRORS))
                            node[6].setText(ras_category(rasState, ZES_RAS_ERROR_CAT_DISPLAY_ERRORS))

                    telemetryClosures.append(rasTelemetry)

        if args.clear_errors and not args.show_telemetry:
            for i in range(edomCount.value()):
                ras = edoms[i]
                try:
                    zeCall(zesRasGetState(ras, True, None))
                except ValueError as err:
                    pr.err("workaround... ERROR: zesRasGetState returned error, ignoring...", err)

        stbyCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumStandbyDomains(device, stbyCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            stbys = zes_standby_handle_array(stbyCount.value())
            zeCall(zesDeviceEnumStandbyDomains(device, stbyCount.cast(), stbys.cast()))

        if args.set_standby is not None:
            for i in range(stbyCount.value()):
                stby = stbys[i]
                if args.set_standby.lower() in ["enabled", "en", "1", "y", "yes", "t", "true"]:
                    if args.dry_run:
                        pr("Would enable standby promotion")
                    else:
                        zeCall(zesStandbySetMode(stby, ZES_STANDBY_PROMO_MODE_DEFAULT))
                elif args.set_standby.lower() in ["disabled", "dis", "0", "n", "no", "f", "false"]:
                    if args.dry_run:
                        pr("Would disable standby promotion")
                    else:
                        zeCall(zesStandbySetMode(stby, ZES_STANDBY_PROMO_MODE_NEVER))
                else:
                    pr.err("WARNING: ignoring unrecognized set-standby value", args.set_standby)

        if args.show_standby:
            stbyTop = Node(devNode, "StandbyDomains", None)

            for i in range(stbyCount.value()):
                stby = stbys[i]
                stbyProps = zes_typed_structure(ZES_STRUCTURE_TYPE_STANDBY_PROPERTIES)
                zeCall(zesStandbyGetProperties(stby, stbyProps))
                stbyType = stbyTypeString(stbyProps.type)

                if stbyProps.onSubdevice:
                    stbyNode = Node(stbyTop, "StandbyDomain", None, ("Index", i), ("Name", stbyType),
                                    ("SubdeviceId", stbyProps.subdeviceId))
                else:
                    stbyNode = Node(stbyTop, "StandbyDomain", None, ("Index", i), ("Name", stbyType))

                if args.show_inventory:
                    modeString = stbyPromoModeString(zeCall(zesStandbyGetMode(stby)))
                    Node(stbyNode, "SleepStateMode", modeString)

        procCount = uint32_ptr()
        try:
            zeCall(zesDeviceProcessesGetState(device, procCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            procs = zes_typed_array(ZES_STRUCTURE_TYPE_PROCESS_STATE, procCount.value())
            zeCall(zesDeviceProcessesGetState(device, procCount.cast(), procs.cast()))

        if args.show_processes:
            procTop = Node(devNode, "ProcessUsages", None)

            for i in range(procCount.value()):
                proc = procs[i]
                procNode = Node(procTop, "ProcessUsage", None, ("Id", proc.processId))

                if args.show_telemetry:
                    Node(procNode, "MemUsage", "0x%08x" % proc.memSize)
                    engineNames = enginesUsedString(proc.engines)
                    Node(procNode, "EngineUsage", engineNames)

        schedCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumSchedulers(device, schedCount.cast(), None))
        except:
            pass
        else:
            scheds = zes_sched_handle_array(schedCount.value())
            zeCall(zesDeviceEnumSchedulers(device, schedCount.cast(), scheds.cast()))

        if args.set_scheduler:
            idx, schedulerArgs = args.set_scheduler[0], args.set_scheduler[1:]
            try:
                i = int(idx)
                assert 0 <= i < schedCount.value()
                sched = scheds[i]
                mode, remainder = arg.parseSchedulerMode(schedulerArgs)
                needsReboot = False
                if mode == ZES_SCHED_MODE_TIMEOUT:
                    schedCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES)
                    watchdogTimeout, remainder = arg.parseMicroseconds(remainder)
                    if watchdogTimeout == 0:
                        zeCall(zesSchedulerGetTimeoutModeProperties(sched, False, schedCfg))
                    else:
                        schedCfg.watchdogTimeout = watchdogTimeout
                    if args.dry_run:
                        pr("Would set scheduling mode to timeout")
                    else:
                        needsReboot = zeCall(zesSchedulerSetTimeoutMode(sched, schedCfg))
                elif mode == ZES_SCHED_MODE_TIMESLICE:
                    schedCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES)
                    interval, remainder = arg.parseMicroseconds(remainder)
                    yieldTimeout, remainder = arg.parseMicroseconds(remainder)
                    if interval == 0 or yieldTimeout == 0:
                        zeCall(zesSchedulerGetTimesliceModeProperties(sched, False, schedCfg))
                    if interval != 0:
                        schedCfg.interval = interval
                    if yieldTimeout != 0:
                        schedCfg.yieldTimeout = yieldTimeout
                    if args.dry_run:
                        pr("Would set scheduling mode to timeslice")
                    else:
                        needsReboot = zeCall(zesSchedulerSetTimesliceMode(sched, schedCfg))
                elif mode == ZES_SCHED_MODE_EXCLUSIVE:
                    if args.dry_run:
                        pr("Would set scheduling mode to exclusive")
                    else:
                        needsReboot = zeCall(zesSchedulerSetExclusiveMode(sched))
                elif mode == ZES_SCHED_MODE_COMPUTE_UNIT_DEBUG:
                    if args.dry_run:
                        pr("Would set scheduling mode to compute unit debug")
                    else:
                        needsReboot = zeCall(zesSchedulerSetComputeUnitDebugMode(sched))
                if remainder:
                    pr.err("WARNING: Extra set-scheduler arguments ignored")
                    pr.err(remainder)
                if needsReboot:
                    pr.err("NOTE: reboot required")
            except:
                pr.fail("Must specify a valid scheduler index and supported mode")

        if args.show_scheduler:
            schedTop = Node(devNode, "Schedulers", None)
            for i in range(schedCount.value()):
                sched = scheds[i]
                schedProps = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_PROPERTIES)
                try:
                    zeCall(zesSchedulerGetProperties(sched, schedProps))
                except NotImplementedError:
                    continue
                except ValueError:
                    logger.reportZeException()
                    continue

                if schedProps.onSubdevice:
                    schedNode = Node(schedTop, "Scheduler", None, ("Index", i),
                                     ("SubdeviceId", rasProps.subdeviceId))
                else:
                    schedNode = Node(schedTop, "Scheduler", None, ("Index", i))

                if args.show_inventory:
                    Node(schedNode, "CanControl", bool(schedProps.canControl))
                    Node(schedNode, "Engines", enginesUsedString(schedProps.engines))
                    Node(schedNode, "SupportedModes", schedSupportedModesString(schedProps.supportedModes))
                    if args.verbose:
                        timeoutCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES)
                        zeCall(zesSchedulerGetTimeoutModeProperties(sched, True, timeoutCfg))
                        if timeoutCfg.watchdogTimeout == ZES_SCHED_WATCHDOG_DISABLE:
                            Node(schedNode, "DefaultTimeout", "Disabled")
                        else:
                            wd = timeoutCfg.watchdogTimeout / 1000.0
                            Node(schedNode, "DefaultTimeout", "%.3f" % wd, ("Units", "msec"))
                        tsCfg = zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES)
                        zeCall(zesSchedulerGetTimesliceModeProperties(sched, True, tsCfg))
                        tsi = tsCfg.interval / 1000.0
                        tsy = tsCfg.yieldTimeout / 1000.0
                        Node(schedNode, "DefaultInterval", "%.3f" % tsi, ("Units", "msec"))
                        Node(schedNode, "DefaultYieldTimeout", "%.3f" % tsy, ("Units", "msec"))

                if args.show_telemetry:
                    cfgs = [zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMEOUT_PROPERTIES),
                            zes_typed_structure(ZES_STRUCTURE_TYPE_SCHED_TIMESLICE_PROPERTIES)]
                    nodes = []
                    nodes.append(Node(schedNode, "Mode", "?"))
                    nodes.append(Node(schedNode, "Timeout", "?", ("Units", "msec")))
                    nodes.append(Node(schedNode, "Interval", "?", ("Units", "msec")))
                    nodes.append(Node(schedNode, "YieldTimeout", "?", ("Units", "msec")))

                    def schedTelemetry(sched=sched, node=nodes, cfg=cfgs):
                        try:
                            mode = zeCall(zesSchedulerGetCurrentMode(sched))
                            if mode == ZES_SCHED_MODE_TIMEOUT:
                                zeCall(zesSchedulerGetTimeoutModeProperties(sched, False, cfg[0]))
                            elif mode == ZES_SCHED_MODE_TIMESLICE:
                                zeCall(zesSchedulerGetTimesliceModeProperties(sched, False, cfg[1]))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(schedModeString(mode))
                            if mode == ZES_SCHED_MODE_TIMEOUT:
                                if cfg[0].watchdogTimeout == ZES_SCHED_WATCHDOG_DISABLE:
                                    node[1].setText("Disabled")
                                else:
                                    wd = cfg[0].watchdogTimeout / 1000.0
                                    node[1].setText("%.3f" % wd)
                            else:
                                node[1].setText("?")
                            if mode == ZES_SCHED_MODE_TIMESLICE:
                                tsi = cfg[1].interval / 1000.0
                                tsy = cfg[1].yieldTimeout / 1000.0
                                node[2].setText("%.3f" % tsi)
                                node[3].setText("%.3f" % tsy)
                            else:
                                node[2].setText("?")
                                node[3].setText("?")

                    telemetryClosures.append(schedTelemetry)

        diagCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumDiagnosticTestSuites(device, diagCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            diags = zes_diag_handle_array(diagCount.value())
            zeCall(zesDeviceEnumDiagnosticTestSuites(device, diagCount.cast(), diags.cast()))

        if args.show_diag:
            diagTop = Node(devNode, "TestSuites", None)

            for i in range(diagCount.value()):
                diag = diags[i]
                diagProps = zes_typed_structure(ZES_STRUCTURE_TYPE_DIAG_PROPERTIES)
                zeCall(zesDiagnosticsGetProperties(diag, diagProps))
                if diagProps.onSubdevice:
                    diagNode = Node(diagTop, "TestSuite", None, ("Index", i), ("Name", diagProps.name),
                                    ("SubdeviceId", diagProps.subdeviceId))
                else:
                    diagNode = Node(diagTop, "TestSuite", None, ("Index", i), ("Name", diagProps.name))

                if args.show_inventory and diagProps.haveTests:
                    testCount = uint32_ptr()
                    try:
                        zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), None))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
                    else:
                        tests = zes_diag_test_array(testCount.value())
                        zeCall(zesDiagnosticsGetTests(diag, testCount.cast(), tests.cast()))

                    for t in range(testCount.value()):
                        test = tests[t]
                        Node(diagNode, "Test", test.name, ("Id", test.index))

        fanCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFans(device, fanCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            fans = zes_fan_handle_array(fanCount.value())
            zeCall(zesDeviceEnumFans(device, fanCount.cast(), fans.cast()))

        if args.set_fan_speed_default:
            i, = args.set_fan_speed_default
            if 0 <= i < fanCount.value():
                try:
                    fan = fans[i]
                    zeCall(zesFanSetDefaultMode(fan))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index")

        if args.set_fan_speed_rpm:
            try:
                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))
                maxRPM = fanProps.maxRPM
            except:
                maxRPM = 1000000
            i, rpm = args.set_fan_speed_rpm
            if 0 <= i < fanCount.value() and 0 <= rpm <= maxRPM:
                try:
                    fan = fans[i]
                    speed = zes_fan_speed_t()
                    speed.speed = rpm
                    speed.units = ZES_FAN_SPEED_UNITS_RPM
                    zeCall(zesFanSetFixedSpeedMode(fan, speed))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index")

        if args.set_fan_speed_percent:
            i, pct = args.set_fan_speed_percent
            if 0 <= i < fanCount.value() and 0 <= pct <= 100:
                try:
                    fan = fans[i]
                    speed = zes_fan_speed_t()
                    speed.speed = pct
                    speed.units = ZES_FAN_SPEED_UNITS_PERCENT
                    zeCall(zesFanSetFixedSpeedMode(fan, speed))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index and fan percent")

        if args.set_fan_speed_table_rpm:
            try:
                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))
                maxRPM = fanProps.maxRPM
                maxPoints = fanProps.maxPoints
            except:
                maxRPM = 1000000
                maxPoints = ZES_FAN_TEMP_SPEED_PAIR_COUNT
            i = args.set_fan_speed_table_rpm[0]
            table = []
            try:
                assert 0 <= i < fanCount.value()
                assert len(args.set_fan_speed_table_rpm) % 2
                temp = -274
                for s in range(1, len(args.set_fan_speed_table_rpm), 2):
                    entry = (args.set_fan_speed_table_rpm[s], args.set_fan_speed_table_rpm[s+1])
                    assert entry[0] > temp
                    temp = entry[0]
                    assert 0 <= entry[1] <= maxRPM
                    table.append(entry)
                assert len(table) <= ZES_FAN_TEMP_SPEED_PAIR_COUNT
                assert len(table) <= maxPoints
            except:
                table = []

            if table:
                try:
                    fan = fans[i]
                    fanTable = zes_fan_speed_table_t()
                    tempSpeed = zes_fan_temp_speed_array(len(table))
                    for t,entry in indexed(table):
                        item = tempSpeed[t]
                        item.temperature = entry[0]
                        item.speed.speed = entry[1]
                        item.speed.units = ZES_FAN_SPEED_UNITS_RPM
                        tempSpeed[t] = item
                    fan_speed_table_set(fanTable, len(table), tempSpeed.cast())
                    zeCall(zesFanSetSpeedTableMode(fan, fanTable))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index and rpm table")

        if args.set_fan_speed_table_percent:
            try:
                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))
                maxPoints = fanProps.maxPoints
            except:
                maxPoints = ZES_FAN_TEMP_SPEED_PAIR_COUNT
            i = args.set_fan_speed_table_percent[0]
            table = []
            try:
                assert 0 <= i < fanCount.value()
                assert len(args.set_fan_speed_table_percent) % 2
                temp = -274
                for s in range(1, len(args.set_fan_speed_table_percent), 2):
                    entry = (args.set_fan_speed_table_percent[s], args.set_fan_speed_table_percent[s+1])
                    assert entry[0] > temp
                    temp = entry[0]
                    assert 0 <= entry[1] <= 100
                    table.append(entry)
                assert len(table) <= ZES_FAN_TEMP_SPEED_PAIR_COUNT
                assert len(table) <= maxPoints
            except:
                table = []

            if table:
                try:
                    fan = fans[i]
                    fanTable = zes_fan_speed_table_t()
                    tempSpeed = zes_fan_temp_speed_array(len(table))
                    for t,entry in indexed(table):
                        item = tempSpeed[t]
                        item.temperature = entry[0]
                        item.speed.speed = entry[1]
                        item.speed.units = ZES_FAN_SPEED_UNITS_PERCENT
                        tempSpeed[t] = item
                    fan_speed_table_set(fanTable, len(table), tempSpeed.cast())
                    zeCall(zesFanSetSpeedTableMode(fan, fanTable))
                except NotImplementedError:
                    pass
                except ValueError:
                    logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid fan index and fan percent table")

        if args.show_fans:
            fanTop = Node(devNode, "Fans", None)

            for i in range(fanCount.value()):
                fan = fans[i]

                fanProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_PROPERTIES)
                zeCall(zesFanGetProperties(fan, fanProps))

                if fanProps.onSubdevice:
                    fanNode = Node(fanTop, "Fan", None, ("Index", i),
                                   ("SubdeviceId", fanProps.subdeviceId))
                else:
                    fanNode = Node(fanTop, "Fan", None, ("Index", i))

                fanConfig = zes_typed_structure(ZES_STRUCTURE_TYPE_FAN_CONFIG)
                zeCall(zesFanGetConfig(fan, fanConfig))

                if args.show_inventory:
                    Node(fanNode, "CanControl", bool(fanProps.canControl))
                    Node(fanNode, "SupportedModes", supportedFanModesString(fanProps.supportedModes))
                    Node(fanNode, "SupportedUnits", supportedFanUnitsString(fanProps.supportedUnits))
                    Node(fanNode, "MaxRPM", knownvalue(fanProps.maxRPM))
                    Node(fanNode, "MaxPoints", knownvalue(fanProps.maxPoints, "Unsupported"))
                    Node(fanNode, "Mode", fanModeString(fanConfig.mode))
                    if fanConfig.mode == ZES_FAN_SPEED_MODE_FIXED:
                        Node(fanNode, "FixedSpeed", fanConfig.speedFixed.speed,
                             ("Units", fanUnitString(fanConfig.speedFixed.units)))
                    # if fanConfig.mode == ZES_FAN_SPEED_MODE_TABLE:
                        # tableSize = fanConfig.speedTable.numPoints
                        # tempSpeed = zes_fan_temp_speed_array(tableSize)
                        # fan_config_speed_table_get(fanConfig, tableSize, tempSpeed.cast())
                        # numPoints = min(tableSize, ZES_FAN_TEMP_SPEED_PAIR_COUNT)
                        # for s in range(numPoints):
                        #     fanTemp = Node(fanNode, "TempSpeed", None)
                        #     item = tempSpeed[s]
                        #     Node(fanTemp, "Temp", item.temperature, ("Units", degC))
                        #     Node(fanTemp, "Speed", item.speed.speed, ("Index", s),
                        #          ("Units", fanUnitString(item.speed.units)))

                if args.show_telemetry:
                    nodes = []
                    nodes.append(Node(fanNode, "Speed", "?",
                                 ("Units", fanUnitString(ZES_FAN_SPEED_UNITS_RPM))))
                    nodes.append(Node(fanNode, "Speed", "?",
                                 ("Units", fanUnitString(ZES_FAN_SPEED_UNITS_PERCENT))))

                    def fanTelemetry(fan=fan, node=nodes):
                        try:
                            rpm = zeCall(zesFanGetState(fan, ZES_FAN_SPEED_UNITS_RPM))
                            pct = zeCall(zesFanGetState(fan, ZES_FAN_SPEED_UNITS_PERCENT))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(rpm)
                            node[1].setText(pct)

                    telemetryClosures.append(fanTelemetry)

        fwCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumFirmwares(device, fwCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            fws = zes_firmware_handle_array(fwCount.value())
            zeCall(zesDeviceEnumFirmwares(device, fwCount.cast(), fws.cast()))

        if args.flash_firmware:
            filename, = args.flash_firmware
            names = ["%s [%s]" % (d,deviceUUID(u)) for d,u in zip(deviceIDs,deviceUUIDs)]
            pr("Requesting flash of", filename, "to the following devices:")
            pr(" " + "\n ".join(names))

            if not args.yes:
                answer = input("Do you really want to flash? ")
                args.yes = answer.lower() in ("y", "yes")

            if args.yes:
                if args.dry_run:
                    pr("Would flash device(s) now")
                else:
                    pr("Preparing to flash devices")
                    zeCall(zesDeviceReset(devices[0], args.force))
                    size = uint32_ptr()
                    with open(filename, "rb") as f:
                        image = f.read()
                    for i in range(fwCount.value()):
                        fw = fws[i]
                        pr("Flashing device", names[i])
                        # zeCall(zesFirmwareFlash(fw, image, len(image)))
                        zeCall(zesFirmwareFlashData(fw, image))
            else:
                pr("NOT flashing device(s)")

            sys.exit(0)

        if args.show_firmware:
            fwTop = Node(devNode, "Firmwares", None)

            for i in range(fwCount.value()):
                fw = fws[i]

                fwProps = zes_typed_structure(ZES_STRUCTURE_TYPE_FIRMWARE_PROPERTIES)
                zeCall(zesFirmwareGetProperties(fw, fwProps))

                if fwProps.onSubdevice:
                    fwNode = Node(fwTop, "Firmware", None, ("Index", i),
                                   ("SubdeviceId", fwProps.subdeviceId))
                else:
                    fwNode = Node(fwTop, "Firmware", None, ("Index", i))

                if args.show_inventory:
                    Node(fwNode, "CanControl", bool(fwProps.canControl))
                    Node(fwNode, "Name", fwProps.name)
                    Node(fwNode, "Version", fwProps.version)

        ledCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumLeds(device, ledCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            leds = zes_led_handle_array(ledCount.value())
            zeCall(zesDeviceEnumLeds(device, ledCount.cast(), leds.cast()))

        if args.enable_led:
            i, = args.enable_led
            if 0 <= i < ledCount.value():
                if args.dry_run:
                    pr("Would enable led", i)
                else:
                    try:
                        led = leds[i]
                        zeCall(zesLedSetState(led, True))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid led index")

        if args.disable_led:
            i, = args.disable_led
            if 0 <= i < ledCount.value():
                if args.dry_run:
                    pr("Would disable led", i)
                else:
                    try:
                        led = leds[i]
                        zeCall(zesLedSetState(led, False))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()
            else:
                pr.fail("ERROR: must specify a valid led index")

        if args.set_led_color:
            idx,colors = args.set_led_color[0], args.set_led_color[1:]
            if len(colors) == 1:
                ledColors = {
                    "white" : (1.0, 1.0, 1.0),
                    "yellow" : (1.0, 1.0, 0.0),
                    "magenta" : (1.0, 0.0, 1.0),
                    "red" : (1.0, 0.0, 0.0),
                    "gray" : (0.5, 0.5, 0.5),
                    "grey" : (0.5, 0.5, 0.5),
                    "cyan" : (0.0, 1.0, 1.0),
                    "green" : (0.0, 1.0, 0.0),
                    "blue" : (0.0, 0.0, 1.0),
                    "black" : (0.0, 0.0, 0.0) }
                colorStr, = colors
                colors = ledColors.get(colorStr.lower())
            try:
                i = int(idx)
                assert 0 <= i < ledCount.value()
                redStr, greenStr, blueStr = colors
                red, green, blue = float(redStr), float(greenStr), float(blueStr)
                assert 0.0 <= red <= 1.0
                assert 0.0 <= green <= 1.0
                assert 0.0 <= blue <= 1.0
            except:
                pr.fail("ERROR: must specify a valid led index and color name or triplet 0-1 0-1 0-1")
            else:
                color = zes_led_color_t()
                color.red, color.green, color.blue = red, green, blue
                if args.dry_run:
                    pr("Would set led", i, "color to", colorString(color))
                else:
                    try:
                        led = leds[i]
                        zeCall(zesLedSetColor(led, color))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()

        if args.show_leds:
            ledTop = Node(devNode, "Leds", None)

            for i in range(ledCount.value()):
                led = leds[i]

                ledProps = zes_typed_structure(ZES_STRUCTURE_TYPE_LED_PROPERTIES)
                zeCall(zesLedGetProperties(led, ledProps))

                if ledProps.onSubdevice:
                    ledNode = Node(ledTop, "Led", None, ("Index", i),
                                   ("SubdeviceId", ledProps.subdeviceId))
                else:
                    ledNode = Node(ledTop, "Led", None, ("Index", i))

                if args.show_inventory:
                    Node(ledNode, "CanControl", bool(ledProps.canControl))
                    Node(ledNode, "HaveRGB", bool(ledProps.haveRGB))

                if args.show_telemetry:
                    ledState = zes_typed_structure(ZES_STRUCTURE_TYPE_LED_STATE)
                    nodes = []
                    nodes.append(Node(ledNode, "State", "?"))
                    if ledProps.haveRGB:
                        nodes.append(Node(ledNode, "Color", "?"))

                    def ledTelemetry(led=led, node=nodes, ledState=ledState):
                        try:
                            zeCall(zesLedGetState(led, ledState))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(onOffString(ledState.isOn))
                            if len(node) > 1:
                                node[1].setText(colorString(ledState.color))

                    telemetryClosures.append(ledTelemetry)

        perfCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumPerformanceFactorDomains(device, perfCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            perfs = zes_perf_handle_array(perfCount.value())
            zeCall(zesDeviceEnumPerformanceFactorDomains(device, perfCount.cast(), perfs.cast()))

        if args.set_perf:
            idx,valStr = args.set_perf
            try:
                i = int(idx)
                assert 0 <= i < perfCount.value()
                val = float(valStr)
                assert 0.0 <= val <= 100.0
            except:
                pr.fail("ERROR: must specify a valid performance factor index and value (0 - 100)")
            else:
                if args.dry_run:
                    pr("Would set performance factor", i, "to", val)
                else:
                    try:
                        perf = perfs[i]
                        zeCall(zesPerformanceFactorSetConfig(perf, val))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()

        if args.show_perf:
            perfTop = Node(devNode, "PerformanceFactors", None)

            for i in range(perfCount.value()):
                perf = perfs[i]

                perfProps = zes_typed_structure(ZES_STRUCTURE_TYPE_PERF_PROPERTIES)
                zeCall(zesPerformanceFactorGetProperties(perf, perfProps))

                if perfProps.onSubdevice:
                    perfNode = Node(perfTop, "PerformanceFactor", None, ("Index", i),
                                   ("SubdeviceId", perfProps.subdeviceId))
                else:
                    perfNode = Node(perfTop, "PerformanceFactor", None, ("Index", i))

                if args.show_inventory:
                    Node(perfNode, "Engines", enginesUsedString(perfProps.engines))

                if args.show_telemetry:
                    nodes = []
                    nodes.append(Node(perfNode, "Value", "?", ("Units", "%")))

                    def perfTelemetry(perf=perf, node=nodes):
                        try:
                            val = zeCall(zesPerformanceFactorGetConfig(perf))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(val)

                    telemetryClosures.append(perfTelemetry)

        psuCount = uint32_ptr()
        try:
            zeCall(zesDeviceEnumPsus(device, psuCount.cast(), None))
        except NotImplementedError:
            pass
        except ValueError:
            logger.reportZeException()
        else:
            psus = zes_psu_handle_array(psuCount.value())
            zeCall(zesDeviceEnumPsus(device, psuCount.cast(), psus.cast()))

        if args.set_perf:
            idx,valStr = args.set_perf
            try:
                i = int(idx)
                assert 0 <= i < perfCount.value()
                val = float(valStr)
                assert 0.0 <= val <= 100.0
            except:
                pr.fail("ERROR: must specify a valid performance factor index and value (0 - 100)")
            else:
                if args.dry_run:
                    pr("Would set performance factor", i, "to", val)
                else:
                    try:
                        perf = perfs[i]
                        zeCall(zesPerformanceFactorSetConfig(perf, val))
                    except NotImplementedError:
                        pass
                    except ValueError:
                        logger.reportZeException()

        if args.show_psu:
            psuTop = Node(devNode, "PowerSupplies", None)

            for i in range(psuCount.value()):
                psu = psus[i]

                psuProps = zes_typed_structure(ZES_STRUCTURE_TYPE_PSU_PROPERTIES)
                zeCall(zesPsuGetProperties(psu, psuProps))

                if psuProps.onSubdevice:
                    psuNode = Node(psuTop, "PowerSupply", None, ("Index", i),
                                   ("SubdeviceId", psuProps.subdeviceId))
                else:
                    psuNode = Node(psuTop, "PowerSupply", None, ("Index", i))

                if args.show_inventory:
                    Node(psuNode, "HaveFan", bool(psuProps.haveFan))
                    Node(psuNode, "CurrentLimit", fmtknown(psuProps.ampLimit / 1000, "%.3f"),
                         ('Units', 'Amps'))

                if args.show_telemetry:
                    psuState = zes_typed_structure(ZES_STRUCTURE_TYPE_PSU_STATE)
                    nodes = []
                    nodes.append(Node(psuNode, "VoltageStatus", "?"))
                    nodes.append(Node(psuNode, "FanFailed", "?"))
                    nodes.append(Node(psuNode, "Temperature", "?"))
                    nodes.append(Node(psuNode, "Current", "?", ('Units', 'Amps')))

                    def psuTelemetry(psu=psu, node=nodes, psuState=psuState):
                        try:
                            zeCall(zesPsuGetState(psu, psuState))
                        except NotImplementedError:
                            pass
                        except ValueError:
                            logger.reportZeException()
                        else:
                            node[0].setText(psuVoltageStatusString(psuState.voltStatus))
                            node[1].setText(bool(psuState.fanFailed))
                            node[2].setText(fmtknown(psuState.temperature))
                            node[3].setText(fmtknown(psuState.current / 1000, "%.3f"))

                    telemetryClosures.append(psuTelemetry)

    currentIteration = 0
    while currentIteration < state.maxIterations:
        if pollDelayRequired:
            time.sleep(pollInterval)

        for closure in telemetryClosures:
            closure()

        currentIteration += 1
        topNode.output(currentIteration)
        pollDelayRequired = True

    topNode.outputComplete()

if __name__ == "__main__":
    main()
